{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Laboratory \u2697\ufe0f \u00b6 A feature flags management library for multi-module Kotlin Android projects. Laboratory offers: Encapsulation : Different feature flags can freely live in separate Gradle modules without being exposed outside. Type safety : Feature flags are represented with concrete types instead of booleans or grouped enums. A/B/n testing : Feature flags don\u2019t have to be constrained to provide only a binary choice. They can have as many states as you\u2019d like. Multiple sources : Feature flags can have different sources used for their current options. For example, you can have a feature flag that takes its option either from a local source or from any number of remote sources like, for instance, Firebase or Azure. QA integration : Laboratory offers great QA capabilities and easy integration with popular tools. It comes with an out-of-the-box Hyperion plugin. Persistence ignorance : Laboratory does not care how you want to store your feature flags. It provides implementations for most common scenarios, but you can always use an implementation for your custom storage mechanism. Testing support : The in-memory implementation can be used as a drop-in substitute for Laboratory instances in tests. Coroutines support : Changes to feature flags can be observed via Flow . Options reads and writes are made with suspend functions, but you can always opt-in to a blocking equivalent of I/O functions. TLDR \u00b6 First, you need to define your feature flags. enum class AuthType : Feature < AuthType > { None , Fingerprint , Retina , Face ; public override val defaultOption get () = Fingerprint } Once you have your feature flags defined, you can start using them in the application. suspend fun main () { // A high-level API for interaction with feature flags val laboratory = Laboratory . inMemory () // Set AuthType option to Fingerprint val success = laboratory . setOption ( AuthType . Fingerprint ) // Check what is the current option of AuthType val currentAuthType = laboratory . experiment < AuthType > () // Check if the current option of AuthType is equal to Face val isFaceAuth = laboratory . experimentIs ( AuthType . Face ) // Observe changes to the AuthType feature flag laboratory . observe < AuthType > () . onEach { option -> println ( \"AuthType: $ option \" ) } . launchIn ( GlobalScope ) } Requirements \u00b6 Laboratory requires Java 8 bytecode support. You can enable it with the following configuration in a build.gradle file. android { compileOptions { sourceCompatibility JavaVersion . VERSION_17 targetCompatibility JavaVersion . VERSION_17 } kotlinOptions { jvmTarget = JavaVersion . VERSION_17 . toString () } } Also, you have to enable default methods generation by Kotlin compiler. You can do this by adding a compiler flag in a build.gradle file. android { kotlinOptions { freeCompilerArgs += [ \"-Xjvm-default=all\" , ] } } R8 \u00b6 Laboratory ships with R8 rules and doesn\u2019t require any extra configuration. Get Laboratory \u00b6 Laboratory is published to Maven Central Repository . repositories { mavenCentral () } dependencies { implementation \"io.mehow.laboratory:laboratory:1.1.0\" } Snapshots of the development version are available on Sonatype\u2019s snapshots repository . Here is the list of all available artifacts that Laboratory library provides. io.mehow.laboratory:laboratory:1.1.0 : Core of the library. Defines classes and interfaces that you can interact with from your application code. It also provides R8 rules. io.mehow.laboratory:laboratory-shared-preferences:1.1.0 : Provides implementation of FeatureStorage based on SharedPreferences . io.mehow.laboratory:laboratory-data-store:1.1.0 : Provides implementation of FeatureStorage based on Jetpack DataStore . io.mehow.laboratory:laboratory-inspector:1.1.0 : QA module that allows users to preview all features and change them at runtime from one place. io.mehow.laboratory:laboratory-hyperion-plugin:1.1.0 : QA module that integrates laboratory-inspector with Hyperion . io.mehow.laboratory:laboratory-gradle-plugin:1.1.0 : Gradle plugin for feature flags generation and other quality of life improvements. It is highly recommended to use it instead of manual class management. License \u00b6 Copyright 2020 Micha\u0142 Sikora Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Quick start"},{"location":"#laboratory","text":"A feature flags management library for multi-module Kotlin Android projects. Laboratory offers: Encapsulation : Different feature flags can freely live in separate Gradle modules without being exposed outside. Type safety : Feature flags are represented with concrete types instead of booleans or grouped enums. A/B/n testing : Feature flags don\u2019t have to be constrained to provide only a binary choice. They can have as many states as you\u2019d like. Multiple sources : Feature flags can have different sources used for their current options. For example, you can have a feature flag that takes its option either from a local source or from any number of remote sources like, for instance, Firebase or Azure. QA integration : Laboratory offers great QA capabilities and easy integration with popular tools. It comes with an out-of-the-box Hyperion plugin. Persistence ignorance : Laboratory does not care how you want to store your feature flags. It provides implementations for most common scenarios, but you can always use an implementation for your custom storage mechanism. Testing support : The in-memory implementation can be used as a drop-in substitute for Laboratory instances in tests. Coroutines support : Changes to feature flags can be observed via Flow . Options reads and writes are made with suspend functions, but you can always opt-in to a blocking equivalent of I/O functions.","title":"Laboratory \u2697\ufe0f"},{"location":"#tldr","text":"First, you need to define your feature flags. enum class AuthType : Feature < AuthType > { None , Fingerprint , Retina , Face ; public override val defaultOption get () = Fingerprint } Once you have your feature flags defined, you can start using them in the application. suspend fun main () { // A high-level API for interaction with feature flags val laboratory = Laboratory . inMemory () // Set AuthType option to Fingerprint val success = laboratory . setOption ( AuthType . Fingerprint ) // Check what is the current option of AuthType val currentAuthType = laboratory . experiment < AuthType > () // Check if the current option of AuthType is equal to Face val isFaceAuth = laboratory . experimentIs ( AuthType . Face ) // Observe changes to the AuthType feature flag laboratory . observe < AuthType > () . onEach { option -> println ( \"AuthType: $ option \" ) } . launchIn ( GlobalScope ) }","title":"TLDR"},{"location":"#requirements","text":"Laboratory requires Java 8 bytecode support. You can enable it with the following configuration in a build.gradle file. android { compileOptions { sourceCompatibility JavaVersion . VERSION_17 targetCompatibility JavaVersion . VERSION_17 } kotlinOptions { jvmTarget = JavaVersion . VERSION_17 . toString () } } Also, you have to enable default methods generation by Kotlin compiler. You can do this by adding a compiler flag in a build.gradle file. android { kotlinOptions { freeCompilerArgs += [ \"-Xjvm-default=all\" , ] } }","title":"Requirements"},{"location":"#r8","text":"Laboratory ships with R8 rules and doesn\u2019t require any extra configuration.","title":"R8"},{"location":"#get-laboratory","text":"Laboratory is published to Maven Central Repository . repositories { mavenCentral () } dependencies { implementation \"io.mehow.laboratory:laboratory:1.1.0\" } Snapshots of the development version are available on Sonatype\u2019s snapshots repository . Here is the list of all available artifacts that Laboratory library provides. io.mehow.laboratory:laboratory:1.1.0 : Core of the library. Defines classes and interfaces that you can interact with from your application code. It also provides R8 rules. io.mehow.laboratory:laboratory-shared-preferences:1.1.0 : Provides implementation of FeatureStorage based on SharedPreferences . io.mehow.laboratory:laboratory-data-store:1.1.0 : Provides implementation of FeatureStorage based on Jetpack DataStore . io.mehow.laboratory:laboratory-inspector:1.1.0 : QA module that allows users to preview all features and change them at runtime from one place. io.mehow.laboratory:laboratory-hyperion-plugin:1.1.0 : QA module that integrates laboratory-inspector with Hyperion . io.mehow.laboratory:laboratory-gradle-plugin:1.1.0 : Gradle plugin for feature flags generation and other quality of life improvements. It is highly recommended to use it instead of manual class management.","title":"Get Laboratory"},{"location":"#license","text":"Copyright 2020 Micha\u0142 Sikora Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this document. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 1.1.0 - 2023-06-13 \u00b6 Changed \u00b6 Upgrade Kotlin to 1.8.21 . Upgrade Wire to 4.7.0 . Upgrade KotlinPoet to 1.14.2 . Upgrade Gradle to 8.1.1 . Upgrade Hyperion to 0.9.37 . Upgrade Coroutines to 1.6.4 . Upgrade AppCompat to 1.6.1 . Upgrade ViewModel-ktx to 2.6.1 . Upgrade Fragment-ktx to 1.5.7 . Upgrade RecyclerView to 1.3.0 . Upgrade Material to 1.9.0 . Upgrade target and source compatibilities versions to Java 17. Change compile and target SDK to 33. 1.0.3 - 2022-10-01 \u00b6 Fixed \u00b6 Generating feature flags and related classes to empty Kotlin source sets in Kotlin 1.7.20 . 1.0.2 - 2022-09-29 \u00b6 Fixed \u00b6 Fixed IllegalArgumentException: Did not find Kotlin source set after upgrading to Kotlin 1.7.20 . 1.0.1 - 2022-06-21 \u00b6 Added \u00b6 Gradle configuration cache support. Removed \u00b6 CoreKtx dependency. 1.0.0 - 2021-02-06 \u00b6 Added \u00b6 setOptions(options) overload which accepts collection instead of varargs. Removed \u00b6 ConstraintLayout dependency. DynamicAnimation dependency. 1.0.0-rc2 - 2021-12-28 \u00b6 Changed \u00b6 SharedPreferencesFeatureStorage no marked as experimental due to coroutines. Upgrade Kotlin to 1.6.10 . Upgrade to Coroutines 1.6.0 . Upgrade Wire to 4.0.1 . Fixed \u00b6 Handle usage of deprecated features in a generated OptionFactory . Removed \u00b6 Builders for generator models. Models are now created via constructors and throw if data is invalid. GenerationFailure interface. Arrow dependency. 1.0.0-rc1 - 2021-12-22 \u00b6 Added \u00b6 Multi-module setup no longer includes other modules implicitly. Instead each module needs to be included via dependency function in Gradle. laboratory { featureFactory () // Before, these were included implicitly. dependency ( project ( \":module-a\" )) dependency ( project ( \":module-b\" )) } Changed \u00b6 Upgrade Android target and compile SDK to 31. Upgrade to LifecycleViewmodelKtx 2.4.0 . Upgrade to KotlinPoet 1.10.2 . Upgrade to Wire 4.0.0 . Upgrade to Kotlin 1.6.0 . Upgrade to ConstraintLayout 2.1.2 . Upgrade to FragmentKtx 1.4.0 . Upgrade to AppCompat 1.4.0 . Removed \u00b6 Groovy DSL introduced in 0.9.0 for adding feature flags. projectFilter properties from Gradle plugin. Use explicit dependencies instead. Deprecated API. Fixed \u00b6 Overrides of sources in DefaultOptionFactory are now respected by Laboratory - #220 . 0.14.0 - 2021-10-11 \u00b6 Added \u00b6 Better integration with remote sources, like Firebase, via OptionFactory interface. It creates feature options based on a feature key and an option name. Code generation of option factory via Gradle plugin. Changed \u00b6 Make Feature and other related classes covariant. FeatureStorage functions are no longer parameterized over Feature . They accept raw class type instead. Generator and Gradle plugin no longer validate package names, duplicates and other things that are checked by compiler. Model builders accept now ClassName in constructor. Mark SharedPreferencesFeatureStorage with ExperimentalCoroutinesApi annotation. Upgrade to Kotlin 1.5.31 . Upgrade to Material 1.4.0 . Upgrade to CoreKtx 1.6.0 . Upgrade to DataStore 1.0.0 . Upgrade to AGP 4.2.2 . Upgrade to Hyperion 0.9.34 . Upgrade to FragmentKtx 1.3.6 . Upgrade to AppCompat 1.3.1 . Upgrade to ConstraintLayout 2.1.1 . Upgrade to ArrowKt 1.0.0 . Upgrade to Coroutines 1.5.2 . Upgrade to KotlinPoet 1.10.1 . Deprecated \u00b6 FeatureStorage.Companion.sharedPreferences(Context) function. Use overload that accepts SharedPreferences instead. FeatureStorage.Companion.dataStore(() -> File) function. Use overload that accepts DataStore instead. FeatureStorage.Companion.dataStore(Context, String) function. Use overload that accepts DataStore instead. generate() methods on generation models. Use prepare() and operate on FileSpec directly instead. Removed \u00b6 Dependency on Kyrie. Dependency on JCenter. 0.13.1 - 2021-06-27 \u00b6 Changed \u00b6 Upgrade to Kotlin 1.5.20 . Upgrade to RecyclerView 1.2.1 . Upgrade to FragmentKtx 1.3.5 . Upgrade to DataStore 1.0.0-beta02 . Upgrade to KotlinPoet 1.9.0 . Upgrade to CoreKtx 1.5.0 . Upgrade to AppCompat 1.3.0 . 0.13.0 - 2021-05-17 \u00b6 Changed \u00b6 Drop deprecated @JvmDefault and switch to JVM default modes . Upgrade to Kotlin 1.5.0 . Upgrade to Coroutines 1.5.0 . Upgrade to AGP 4.2.1 . Upgrade to KotlinPoet 1.8.0 . Upgrade to RecyclerView 1.2.0 . Upgrade to Hyperion 0.9.32 . Upgrade to FragmentKtx 1.3.3 . Upgrade to DataStore 1.0.0-beta01 . 0.12.1 - 2021-03-28 \u00b6 Added \u00b6 Indication that an option is a supervisor. If an option supervises features it has an eye icon next to it. List of supervised features is available after long pressing a chip. Navigation from supervised feature to supervisor. Navigation from supervisor to supervised feature. Amount of offscreen feature sections in inspector can be controlled with LaboratoryActivity.Configuration.OffscreenSectionsBehavior . Default is unlimited. Changed \u00b6 Upgrade to Kotlin 1.4.32 . Upgrade to LifecycleViewmodelKtx 2.3.1 . Upgrade to FragmentKtx 1.3.2 . Upgrade to Wire 3.7.0 . 0.12.0 - 2021-03-21 \u00b6 Added \u00b6 Gradle plugin generates sourcedBuilder() extension function for SourcedFeatureStorage that returns custom builder with steps for each source. This makes changes to sources compile time safe. Show feature\u2019s supervisor option in inspector \u2013 #95 . Changed \u00b6 Upgrade to Coroutines 1.4.3 . Upgrade to AGP 4.1.3 . Deprecated \u00b6 sourcedGenerated() extension function generated by Gradle plugin. 0.11.0 - 2021-03-11 \u00b6 Changed \u00b6 Use proto3 for FeatureFlags definition. Upgrade to DataStore 1.0.0-alpha08 . Upgrade to Kotlin 1.4.31 . Upgrade to Wire 3.6.1 . Upgrade to FragmentKtx 1.3.1 . 0.10.0 - 2021-02-18 \u00b6 Added \u00b6 Parent\u2013child relationship to Feature . This relationship is controlled with a Feature.supervisorOption property. Whenever supervisor has its option different from this value then the supervised feature flag cannot return any other option than a default one. Option can still be set via Laboratory but it will not be exposed as long as a feature flag is not supervised. This relationship is recursive meaning that grandparents control grandchildren indirectly. Code generation of supervisor options via Gradle plugin. Changed \u00b6 Gradle plugin no longer changes implicit package name multiple times. Only last value that was set is applied in configuration. Upgrade to DataStore 1.0.0-alpha06 . Upgrade to AGP 4.1.2 . Upgrade to Kotlin 1.4.30 . Upgrade to Wire 3.6.0 . Upgrade to Material 1.3.0 . Upgrade to FragmentKtx 1.3.0 . Upgrade to LifecycleViewmodelKtx 2.3.0 . Upgrade to Hyperion 0.9.31 . Fixed \u00b6 Search icon not animating on Android below SDK 24. Deprecated \u00b6 DataStore custom builder and builder factory methods. Factory method that accepts DataStore directly should be used instead. 0.9.7 - 2020-12-15 \u00b6 Changed \u00b6 DeprecationLevel.Hidden is no longer deprecated. It was a mistake to deprecate it at all since it could work from the start. 0.9.6 - 2020-12-15 \u00b6 Added \u00b6 FeatureFactory can be now appended to another with plus operator. DefaultOptionFactory can be now appended to another with plus operator. Changed \u00b6 Use description as feature flag\u2019s KDoc content. Upgrade Kotlin to 1.4.21 . Deprecated \u00b6 Using DeprecationLevel.Hidden is temporarily treated as an error until the compiler issue is fixed. Fixed \u00b6 Make updates to the in-memory Laboratory atomic. 0.9.5 - 2020-12-03 \u00b6 Added \u00b6 Builder pattern for LaboratoryActivity.Configuration construction. Visual representation of deprecated feature flags in the QA module. Visual representation of deprecated feature flags can be configured via LaboratoryActivity.Configuration builder with deprecationPhenotypeSelector() and deprecationAlignmentSelector() functions. Consumer ProGuard rules to laboratory-inspector to keep @Deprecated annotation. QA module displays clickable hyperlinks from a feature flag description if it contains Markdown formatted links. Changed \u00b6 Upgrade to DataStore 1.0.0-alpha05 . Deprecated \u00b6 LaboratoryActivity.Configuration() constructor. Use LaboratoryActivity.Configuration.create() or LaboratoryActivity.Configuration.builder() instead. Fixed \u00b6 Warning and error level deprecation on generated feature flags is now correctly suppressed. 0.9.4 - 2020-11-27 \u00b6 Added \u00b6 Kyrie 0.2.1 to laboratory-inspector . DynamicAnimation 1.0.0 to laboratory-inspector . Changed \u00b6 Animation of search feature in inspector. It no longer makes ugly visibility transitions. Upgrade to Coroutines 1.4.2 . 0.9.3 - 2020-11-23 \u00b6 Added \u00b6 Feature flags filtering to the QA module. Features are filtered by their name, options or source options. ConstraintLayout 2.0.4 to laboratory-inspector . Changed \u00b6 Inspector tabs are now scrollable instead of fixed. Upgrade to Kotlin 1.4.20 . Fixed \u00b6 Shared preferences based FeatureStorage dispatches now changes to feature flag observers when clear() method is used. This fixes an issue with the QA module where it did not update the UI after resetting feature flags if shared preferences where used for feature flags persistence. Preserve feature flags preview adapter scroll position on configuration changes. External feature factories are no longer filtered out when added with the configure() function. 0.9.2 - 2020-11-18 \u00b6 Added \u00b6 BlockingLaboratory class that can read and write feature flags via blocking API. blocking() function to Laboratory class that is an entry point to the blocking API. Deprecation of feature flags from the Gradle plugin with deprecated(message, level) method. level argument is optional and a warning level is used by default. Changed \u00b6 Upgrade to DataStore 1.0.0-alpha04 . Deprecated \u00b6 All blocking functions on the Laboratory class. BlockingLaboratory available via blocking() function should be used instead. 0.9.1 - 2020-11-12 \u00b6 Added \u00b6 Builder pattern for Laboratory construction. DefaultOptionFactory that can substitute default options for feature flags read by Laboratory . clear() function to FeatureStorage and Laboratory . Changed \u00b6 Upgrade to DataStore 1.0.0-alpha03 . Deprecated \u00b6 Laboratory(storage) constructor. Use Laboratory.create(storage) or Laboratory.builder() instead. 0.9.0 - 2020-11-11 \u00b6 Added \u00b6 Groovy DSL for adding feature flags via Gradle plugin. This is equivalent to feature(\"SomeFeatureFlag\") function. laboratory { SomeFeatureFlag { withDefaultOption ( \"Enabled\" ) withOption ( \"Disabled\" ) } } options extension to Class<Feature<T>> that returns all available feature flag options. defaultOption extension to Class<Feature<T>> that returns a default option of a feature flag. source extension to Class<Feature<*>> that returns a feature flag source if available. description extension to Class<Feature<*>> that returns a feature flag description if available. withOption() and withDefaultOption() to Gradle plugin for adding options to feature flags. defaultOption property to Feature interface. setOption() and setOptions() functions to Laboratory and FeatureStorage . Changed \u00b6 excludeProjects plugin functions are now called projectFilter and the condition is reversed. Previously they removed projects that matched a condition. Now they allow projects that match it. sourcedWith property on Feature is now named source . Upgrade to Coroutines 1.4.1 . Deprecated \u00b6 withValue() and withDefaultValue() functions in Gradle plugin. withOption() and withDefaultOption() should be used instead. setFeature() and setFeatures() functions. setOption() and setOptions() should be used instead. Removed \u00b6 ProjectFilter from laboratory-gradle-plugin in favour of java.util.function.Predicate . configure() overload which accepts sources factory as a separate argument. isDefaultValue from Feature interface. defaultOption should be used instead. Fixed \u00b6 Moved generateSourcedFeatureStorage task to a correct tasks group. 0.8.0 - 2020-10-28 \u00b6 Added \u00b6 KDoc documentation. Changed \u00b6 Renamed feature / features argument in setFeature() and setFeatures() methods to value / values respectively. Elevation is no longer an attribute in the IoMehowLaboratory.Theme and a regular resource is used instead. This makes sure that when an Activity theme is overridden externally it won\u2019t crash for an unknown attribute. Flatten Hyperion button to visually match other items. Upgrade to Coroutines 1.4.0 . Upgrade to Wire 3.5.0 . Removed \u00b6 generateFactory property from sourcedFeatureStorage() method in Gradle plugin. It was added to the public API by a mistake and wasn\u2019t responsible for anything. Wire dependency from the library-shared-preferences artifact. It was added by a mistake. BuildConfig classes from Android library modules. 0.7.0 - 2020-10-22 \u00b6 Changed \u00b6 Changelog format follows now Keep a Changelog format. Format is applied retroactively to this file. R8 rules are now a part of META-INF of the laboratory artifact. SharedPreferencesFeatureStorage is now internal . Gradle plugin no longer has a runtime dependency on Android Gradle Plugin. laboratory-generator generates source code compatible with the explicit API mode . Set compile SDK to 30 . Upgrade to KotlinPoet 1.7.2 . Upgrade to Hyperion 0.9.30 . Upgrade to DataStore 1.0.0-alpha02 . 0.6.2 - 2020-10-12 \u00b6 Added \u00b6 FeatureStorage extensions for creation of SharedPreferences based FeatureStorage . FeatureStorage extensions for creation of DataStore based FeatureStorage . Hyperion plugin can be ordered in the debug menu by overriding io_mehow_laboratory_plugin_id resource. Deprecated \u00b6 SharedPreferenceFeatureStorage soon will become internal . Changed \u00b6 DataStoreFeatureStorage is now internal . It is not considered a breaking change as DataStore is in the alpha stage. 0.6.1 - 2020-10-12 \u00b6 Fixed \u00b6 Hyperion plugin layout where button was on the wrong side of the debug menu. 0.6.0 - 2020-10-12 \u00b6 Added \u00b6 Feature can have now description. It can be used to add more contextual data to feature flags. LaboratoryActivity observes changes to feature flags instead of loading them every time the screen is opened. LaboratoryActivity displays feature flag sources next to them and allows users to select a source from a drop down menu. Remote feature flag values are displayed in LaboratoryActivity if a source is not local. When a remote source is used for a feature flag a value cannot be changed from LaboratoryActivity . LaboratoryActivity displays feature flag descriptions if they are present. LaboratoryActivity can reset feature flag values to their default state from an item in the action bar. Laboratory.experimentIs() and Laboratory.experimentIsBlocking() functions that allow to check if a feature flag has particular value. ViewPager2 1.0.0 dependency to laboratory-inspector . RecyclerView 1.1.0 dependency to laboratory-inspector . Changed \u00b6 LaboratoryActivity requires now a Laboratory instance for initialization. This Laboratory should share FeatureStorage with instances of Laboratory used in the application. 0.5.0 - 2020-10-08 \u00b6 Changed \u00b6 fallback nomenclature to default . This affects Gradle plugin withFallbackValue() and withFallbackSources() functions as well as isFallbackValue property on the Feature interface. 0.4.0 - 2020-10-08 \u00b6 Changed \u00b6 Name of the generated sourced FeatureStorage extension function is now sourcedGenerated() in order to align it with the generated feature factory extension function name. 0.3.0 - 2020-10-08 \u00b6 Added \u00b6 Feature flags can have multiple sources. Source is also a feature flag and is optional. If no source is available it is assumed that only a local source is controlled. FeatureStorage that connects feature flags with their sources. It is available via FeatureStorage.sourced() extension function. Feature flag sources are uniquely identified only by their value names. Feature flag sources can be set from the Gradle plugin with withSource(\"Name\") and withFallbackSource(\"Name\") functions in feature() blocks. Any source that has the name \u201cLocal\u201d (or a variant of it) is filtered out. Gradle plugin has a new sourcedStorage() function. It is responsible for generating a customized FeatureStorage that is aware of all available feature flag sources. Gradle plugin has a new featureSourceFactory() function. It works similarly to featureFactory() function with a difference that it collects only feature flag sources. LaboratoryActivity is now configurable with the configure() function . LaboratoryActivity can display different sets of feature flags on separate tabs. FragmentKtx 1.2.5 dependency to laboratory-inspector . ViewModelKtx 2.2.0 dependency to laboratory-inspector . Changed \u00b6 LaboratoryActivity.initialize() function is renamed to configure() . Gradle plugin factory() function is renamed to featureFactory() . 0.2.1 - 2020-10-02 \u00b6 Added \u00b6 Laboratory exposes a blocking way of reading and writing feature flags. It requires an opt-in BlockingIoCall annotation. Changed \u00b6 laboratory-android artifact is now laboratory-shared-preferences artifact. laboratory-shared-preferences artifact (old laboratory-android ) is no longer automatically applied by Gradle plugin in Android modules. Upgrade to Kotlin 1.4.10 . Upgrade to CoreKtx 1.3.2 . Upgrade to Wire 3.4.0 . Upgrade to KotlinPoet 1.6.0 . 0.2.0 - 2020-09-05 \u00b6 Added \u00b6 Laboratory.observe() function to observe feature flag changes via Flow . Support for DataStore with the laboratory-data-store artifact. Laboratory and FeatureStorage return a boolean information whether writes are successful. Feature interface that is used to define feature flags. Wire 3.2.2 dependency to laboratory-data-store . Changed \u00b6 Kotlin standard library is now part of the public API. Laboratory and FeatureStorage expose their API via suspend functions. Gradle plugin requires exactly one feature flag value to be added with withFallbackValue(\"Name\") function. Upgrade to Kotlin 1.4.0 . Upgrade to Material 1.2.1 . Upgrade to Hyperion 0.9.29 . Removed \u00b6 @Feature annotation. Feature flags should implement the Feature interface. 0.1.0 - 2020-08-03 \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this document. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#110-2023-06-13","text":"","title":"1.1.0 - 2023-06-13"},{"location":"changelog/#changed","text":"Upgrade Kotlin to 1.8.21 . Upgrade Wire to 4.7.0 . Upgrade KotlinPoet to 1.14.2 . Upgrade Gradle to 8.1.1 . Upgrade Hyperion to 0.9.37 . Upgrade Coroutines to 1.6.4 . Upgrade AppCompat to 1.6.1 . Upgrade ViewModel-ktx to 2.6.1 . Upgrade Fragment-ktx to 1.5.7 . Upgrade RecyclerView to 1.3.0 . Upgrade Material to 1.9.0 . Upgrade target and source compatibilities versions to Java 17. Change compile and target SDK to 33.","title":"Changed"},{"location":"changelog/#103-2022-10-01","text":"","title":"1.0.3 - 2022-10-01"},{"location":"changelog/#fixed","text":"Generating feature flags and related classes to empty Kotlin source sets in Kotlin 1.7.20 .","title":"Fixed"},{"location":"changelog/#102-2022-09-29","text":"","title":"1.0.2 - 2022-09-29"},{"location":"changelog/#fixed_1","text":"Fixed IllegalArgumentException: Did not find Kotlin source set after upgrading to Kotlin 1.7.20 .","title":"Fixed"},{"location":"changelog/#101-2022-06-21","text":"","title":"1.0.1 - 2022-06-21"},{"location":"changelog/#added","text":"Gradle configuration cache support.","title":"Added"},{"location":"changelog/#removed","text":"CoreKtx dependency.","title":"Removed"},{"location":"changelog/#100-2021-02-06","text":"","title":"1.0.0 - 2021-02-06"},{"location":"changelog/#added_1","text":"setOptions(options) overload which accepts collection instead of varargs.","title":"Added"},{"location":"changelog/#removed_1","text":"ConstraintLayout dependency. DynamicAnimation dependency.","title":"Removed"},{"location":"changelog/#100-rc2-2021-12-28","text":"","title":"1.0.0-rc2 - 2021-12-28"},{"location":"changelog/#changed_1","text":"SharedPreferencesFeatureStorage no marked as experimental due to coroutines. Upgrade Kotlin to 1.6.10 . Upgrade to Coroutines 1.6.0 . Upgrade Wire to 4.0.1 .","title":"Changed"},{"location":"changelog/#fixed_2","text":"Handle usage of deprecated features in a generated OptionFactory .","title":"Fixed"},{"location":"changelog/#removed_2","text":"Builders for generator models. Models are now created via constructors and throw if data is invalid. GenerationFailure interface. Arrow dependency.","title":"Removed"},{"location":"changelog/#100-rc1-2021-12-22","text":"","title":"1.0.0-rc1 - 2021-12-22"},{"location":"changelog/#added_2","text":"Multi-module setup no longer includes other modules implicitly. Instead each module needs to be included via dependency function in Gradle. laboratory { featureFactory () // Before, these were included implicitly. dependency ( project ( \":module-a\" )) dependency ( project ( \":module-b\" )) }","title":"Added"},{"location":"changelog/#changed_2","text":"Upgrade Android target and compile SDK to 31. Upgrade to LifecycleViewmodelKtx 2.4.0 . Upgrade to KotlinPoet 1.10.2 . Upgrade to Wire 4.0.0 . Upgrade to Kotlin 1.6.0 . Upgrade to ConstraintLayout 2.1.2 . Upgrade to FragmentKtx 1.4.0 . Upgrade to AppCompat 1.4.0 .","title":"Changed"},{"location":"changelog/#removed_3","text":"Groovy DSL introduced in 0.9.0 for adding feature flags. projectFilter properties from Gradle plugin. Use explicit dependencies instead. Deprecated API.","title":"Removed"},{"location":"changelog/#fixed_3","text":"Overrides of sources in DefaultOptionFactory are now respected by Laboratory - #220 .","title":"Fixed"},{"location":"changelog/#0140-2021-10-11","text":"","title":"0.14.0 - 2021-10-11"},{"location":"changelog/#added_3","text":"Better integration with remote sources, like Firebase, via OptionFactory interface. It creates feature options based on a feature key and an option name. Code generation of option factory via Gradle plugin.","title":"Added"},{"location":"changelog/#changed_3","text":"Make Feature and other related classes covariant. FeatureStorage functions are no longer parameterized over Feature . They accept raw class type instead. Generator and Gradle plugin no longer validate package names, duplicates and other things that are checked by compiler. Model builders accept now ClassName in constructor. Mark SharedPreferencesFeatureStorage with ExperimentalCoroutinesApi annotation. Upgrade to Kotlin 1.5.31 . Upgrade to Material 1.4.0 . Upgrade to CoreKtx 1.6.0 . Upgrade to DataStore 1.0.0 . Upgrade to AGP 4.2.2 . Upgrade to Hyperion 0.9.34 . Upgrade to FragmentKtx 1.3.6 . Upgrade to AppCompat 1.3.1 . Upgrade to ConstraintLayout 2.1.1 . Upgrade to ArrowKt 1.0.0 . Upgrade to Coroutines 1.5.2 . Upgrade to KotlinPoet 1.10.1 .","title":"Changed"},{"location":"changelog/#deprecated","text":"FeatureStorage.Companion.sharedPreferences(Context) function. Use overload that accepts SharedPreferences instead. FeatureStorage.Companion.dataStore(() -> File) function. Use overload that accepts DataStore instead. FeatureStorage.Companion.dataStore(Context, String) function. Use overload that accepts DataStore instead. generate() methods on generation models. Use prepare() and operate on FileSpec directly instead.","title":"Deprecated"},{"location":"changelog/#removed_4","text":"Dependency on Kyrie. Dependency on JCenter.","title":"Removed"},{"location":"changelog/#0131-2021-06-27","text":"","title":"0.13.1 - 2021-06-27"},{"location":"changelog/#changed_4","text":"Upgrade to Kotlin 1.5.20 . Upgrade to RecyclerView 1.2.1 . Upgrade to FragmentKtx 1.3.5 . Upgrade to DataStore 1.0.0-beta02 . Upgrade to KotlinPoet 1.9.0 . Upgrade to CoreKtx 1.5.0 . Upgrade to AppCompat 1.3.0 .","title":"Changed"},{"location":"changelog/#0130-2021-05-17","text":"","title":"0.13.0 - 2021-05-17"},{"location":"changelog/#changed_5","text":"Drop deprecated @JvmDefault and switch to JVM default modes . Upgrade to Kotlin 1.5.0 . Upgrade to Coroutines 1.5.0 . Upgrade to AGP 4.2.1 . Upgrade to KotlinPoet 1.8.0 . Upgrade to RecyclerView 1.2.0 . Upgrade to Hyperion 0.9.32 . Upgrade to FragmentKtx 1.3.3 . Upgrade to DataStore 1.0.0-beta01 .","title":"Changed"},{"location":"changelog/#0121-2021-03-28","text":"","title":"0.12.1 - 2021-03-28"},{"location":"changelog/#added_4","text":"Indication that an option is a supervisor. If an option supervises features it has an eye icon next to it. List of supervised features is available after long pressing a chip. Navigation from supervised feature to supervisor. Navigation from supervisor to supervised feature. Amount of offscreen feature sections in inspector can be controlled with LaboratoryActivity.Configuration.OffscreenSectionsBehavior . Default is unlimited.","title":"Added"},{"location":"changelog/#changed_6","text":"Upgrade to Kotlin 1.4.32 . Upgrade to LifecycleViewmodelKtx 2.3.1 . Upgrade to FragmentKtx 1.3.2 . Upgrade to Wire 3.7.0 .","title":"Changed"},{"location":"changelog/#0120-2021-03-21","text":"","title":"0.12.0 - 2021-03-21"},{"location":"changelog/#added_5","text":"Gradle plugin generates sourcedBuilder() extension function for SourcedFeatureStorage that returns custom builder with steps for each source. This makes changes to sources compile time safe. Show feature\u2019s supervisor option in inspector \u2013 #95 .","title":"Added"},{"location":"changelog/#changed_7","text":"Upgrade to Coroutines 1.4.3 . Upgrade to AGP 4.1.3 .","title":"Changed"},{"location":"changelog/#deprecated_1","text":"sourcedGenerated() extension function generated by Gradle plugin.","title":"Deprecated"},{"location":"changelog/#0110-2021-03-11","text":"","title":"0.11.0 - 2021-03-11"},{"location":"changelog/#changed_8","text":"Use proto3 for FeatureFlags definition. Upgrade to DataStore 1.0.0-alpha08 . Upgrade to Kotlin 1.4.31 . Upgrade to Wire 3.6.1 . Upgrade to FragmentKtx 1.3.1 .","title":"Changed"},{"location":"changelog/#0100-2021-02-18","text":"","title":"0.10.0 - 2021-02-18"},{"location":"changelog/#added_6","text":"Parent\u2013child relationship to Feature . This relationship is controlled with a Feature.supervisorOption property. Whenever supervisor has its option different from this value then the supervised feature flag cannot return any other option than a default one. Option can still be set via Laboratory but it will not be exposed as long as a feature flag is not supervised. This relationship is recursive meaning that grandparents control grandchildren indirectly. Code generation of supervisor options via Gradle plugin.","title":"Added"},{"location":"changelog/#changed_9","text":"Gradle plugin no longer changes implicit package name multiple times. Only last value that was set is applied in configuration. Upgrade to DataStore 1.0.0-alpha06 . Upgrade to AGP 4.1.2 . Upgrade to Kotlin 1.4.30 . Upgrade to Wire 3.6.0 . Upgrade to Material 1.3.0 . Upgrade to FragmentKtx 1.3.0 . Upgrade to LifecycleViewmodelKtx 2.3.0 . Upgrade to Hyperion 0.9.31 .","title":"Changed"},{"location":"changelog/#fixed_4","text":"Search icon not animating on Android below SDK 24.","title":"Fixed"},{"location":"changelog/#deprecated_2","text":"DataStore custom builder and builder factory methods. Factory method that accepts DataStore directly should be used instead.","title":"Deprecated"},{"location":"changelog/#097-2020-12-15","text":"","title":"0.9.7 - 2020-12-15"},{"location":"changelog/#changed_10","text":"DeprecationLevel.Hidden is no longer deprecated. It was a mistake to deprecate it at all since it could work from the start.","title":"Changed"},{"location":"changelog/#096-2020-12-15","text":"","title":"0.9.6 - 2020-12-15"},{"location":"changelog/#added_7","text":"FeatureFactory can be now appended to another with plus operator. DefaultOptionFactory can be now appended to another with plus operator.","title":"Added"},{"location":"changelog/#changed_11","text":"Use description as feature flag\u2019s KDoc content. Upgrade Kotlin to 1.4.21 .","title":"Changed"},{"location":"changelog/#deprecated_3","text":"Using DeprecationLevel.Hidden is temporarily treated as an error until the compiler issue is fixed.","title":"Deprecated"},{"location":"changelog/#fixed_5","text":"Make updates to the in-memory Laboratory atomic.","title":"Fixed"},{"location":"changelog/#095-2020-12-03","text":"","title":"0.9.5 - 2020-12-03"},{"location":"changelog/#added_8","text":"Builder pattern for LaboratoryActivity.Configuration construction. Visual representation of deprecated feature flags in the QA module. Visual representation of deprecated feature flags can be configured via LaboratoryActivity.Configuration builder with deprecationPhenotypeSelector() and deprecationAlignmentSelector() functions. Consumer ProGuard rules to laboratory-inspector to keep @Deprecated annotation. QA module displays clickable hyperlinks from a feature flag description if it contains Markdown formatted links.","title":"Added"},{"location":"changelog/#changed_12","text":"Upgrade to DataStore 1.0.0-alpha05 .","title":"Changed"},{"location":"changelog/#deprecated_4","text":"LaboratoryActivity.Configuration() constructor. Use LaboratoryActivity.Configuration.create() or LaboratoryActivity.Configuration.builder() instead.","title":"Deprecated"},{"location":"changelog/#fixed_6","text":"Warning and error level deprecation on generated feature flags is now correctly suppressed.","title":"Fixed"},{"location":"changelog/#094-2020-11-27","text":"","title":"0.9.4 - 2020-11-27"},{"location":"changelog/#added_9","text":"Kyrie 0.2.1 to laboratory-inspector . DynamicAnimation 1.0.0 to laboratory-inspector .","title":"Added"},{"location":"changelog/#changed_13","text":"Animation of search feature in inspector. It no longer makes ugly visibility transitions. Upgrade to Coroutines 1.4.2 .","title":"Changed"},{"location":"changelog/#093-2020-11-23","text":"","title":"0.9.3 - 2020-11-23"},{"location":"changelog/#added_10","text":"Feature flags filtering to the QA module. Features are filtered by their name, options or source options. ConstraintLayout 2.0.4 to laboratory-inspector .","title":"Added"},{"location":"changelog/#changed_14","text":"Inspector tabs are now scrollable instead of fixed. Upgrade to Kotlin 1.4.20 .","title":"Changed"},{"location":"changelog/#fixed_7","text":"Shared preferences based FeatureStorage dispatches now changes to feature flag observers when clear() method is used. This fixes an issue with the QA module where it did not update the UI after resetting feature flags if shared preferences where used for feature flags persistence. Preserve feature flags preview adapter scroll position on configuration changes. External feature factories are no longer filtered out when added with the configure() function.","title":"Fixed"},{"location":"changelog/#092-2020-11-18","text":"","title":"0.9.2 - 2020-11-18"},{"location":"changelog/#added_11","text":"BlockingLaboratory class that can read and write feature flags via blocking API. blocking() function to Laboratory class that is an entry point to the blocking API. Deprecation of feature flags from the Gradle plugin with deprecated(message, level) method. level argument is optional and a warning level is used by default.","title":"Added"},{"location":"changelog/#changed_15","text":"Upgrade to DataStore 1.0.0-alpha04 .","title":"Changed"},{"location":"changelog/#deprecated_5","text":"All blocking functions on the Laboratory class. BlockingLaboratory available via blocking() function should be used instead.","title":"Deprecated"},{"location":"changelog/#091-2020-11-12","text":"","title":"0.9.1 - 2020-11-12"},{"location":"changelog/#added_12","text":"Builder pattern for Laboratory construction. DefaultOptionFactory that can substitute default options for feature flags read by Laboratory . clear() function to FeatureStorage and Laboratory .","title":"Added"},{"location":"changelog/#changed_16","text":"Upgrade to DataStore 1.0.0-alpha03 .","title":"Changed"},{"location":"changelog/#deprecated_6","text":"Laboratory(storage) constructor. Use Laboratory.create(storage) or Laboratory.builder() instead.","title":"Deprecated"},{"location":"changelog/#090-2020-11-11","text":"","title":"0.9.0 - 2020-11-11"},{"location":"changelog/#added_13","text":"Groovy DSL for adding feature flags via Gradle plugin. This is equivalent to feature(\"SomeFeatureFlag\") function. laboratory { SomeFeatureFlag { withDefaultOption ( \"Enabled\" ) withOption ( \"Disabled\" ) } } options extension to Class<Feature<T>> that returns all available feature flag options. defaultOption extension to Class<Feature<T>> that returns a default option of a feature flag. source extension to Class<Feature<*>> that returns a feature flag source if available. description extension to Class<Feature<*>> that returns a feature flag description if available. withOption() and withDefaultOption() to Gradle plugin for adding options to feature flags. defaultOption property to Feature interface. setOption() and setOptions() functions to Laboratory and FeatureStorage .","title":"Added"},{"location":"changelog/#changed_17","text":"excludeProjects plugin functions are now called projectFilter and the condition is reversed. Previously they removed projects that matched a condition. Now they allow projects that match it. sourcedWith property on Feature is now named source . Upgrade to Coroutines 1.4.1 .","title":"Changed"},{"location":"changelog/#deprecated_7","text":"withValue() and withDefaultValue() functions in Gradle plugin. withOption() and withDefaultOption() should be used instead. setFeature() and setFeatures() functions. setOption() and setOptions() should be used instead.","title":"Deprecated"},{"location":"changelog/#removed_5","text":"ProjectFilter from laboratory-gradle-plugin in favour of java.util.function.Predicate . configure() overload which accepts sources factory as a separate argument. isDefaultValue from Feature interface. defaultOption should be used instead.","title":"Removed"},{"location":"changelog/#fixed_8","text":"Moved generateSourcedFeatureStorage task to a correct tasks group.","title":"Fixed"},{"location":"changelog/#080-2020-10-28","text":"","title":"0.8.0 - 2020-10-28"},{"location":"changelog/#added_14","text":"KDoc documentation.","title":"Added"},{"location":"changelog/#changed_18","text":"Renamed feature / features argument in setFeature() and setFeatures() methods to value / values respectively. Elevation is no longer an attribute in the IoMehowLaboratory.Theme and a regular resource is used instead. This makes sure that when an Activity theme is overridden externally it won\u2019t crash for an unknown attribute. Flatten Hyperion button to visually match other items. Upgrade to Coroutines 1.4.0 . Upgrade to Wire 3.5.0 .","title":"Changed"},{"location":"changelog/#removed_6","text":"generateFactory property from sourcedFeatureStorage() method in Gradle plugin. It was added to the public API by a mistake and wasn\u2019t responsible for anything. Wire dependency from the library-shared-preferences artifact. It was added by a mistake. BuildConfig classes from Android library modules.","title":"Removed"},{"location":"changelog/#070-2020-10-22","text":"","title":"0.7.0 - 2020-10-22"},{"location":"changelog/#changed_19","text":"Changelog format follows now Keep a Changelog format. Format is applied retroactively to this file. R8 rules are now a part of META-INF of the laboratory artifact. SharedPreferencesFeatureStorage is now internal . Gradle plugin no longer has a runtime dependency on Android Gradle Plugin. laboratory-generator generates source code compatible with the explicit API mode . Set compile SDK to 30 . Upgrade to KotlinPoet 1.7.2 . Upgrade to Hyperion 0.9.30 . Upgrade to DataStore 1.0.0-alpha02 .","title":"Changed"},{"location":"changelog/#062-2020-10-12","text":"","title":"0.6.2 - 2020-10-12"},{"location":"changelog/#added_15","text":"FeatureStorage extensions for creation of SharedPreferences based FeatureStorage . FeatureStorage extensions for creation of DataStore based FeatureStorage . Hyperion plugin can be ordered in the debug menu by overriding io_mehow_laboratory_plugin_id resource.","title":"Added"},{"location":"changelog/#deprecated_8","text":"SharedPreferenceFeatureStorage soon will become internal .","title":"Deprecated"},{"location":"changelog/#changed_20","text":"DataStoreFeatureStorage is now internal . It is not considered a breaking change as DataStore is in the alpha stage.","title":"Changed"},{"location":"changelog/#061-2020-10-12","text":"","title":"0.6.1 - 2020-10-12"},{"location":"changelog/#fixed_9","text":"Hyperion plugin layout where button was on the wrong side of the debug menu.","title":"Fixed"},{"location":"changelog/#060-2020-10-12","text":"","title":"0.6.0 - 2020-10-12"},{"location":"changelog/#added_16","text":"Feature can have now description. It can be used to add more contextual data to feature flags. LaboratoryActivity observes changes to feature flags instead of loading them every time the screen is opened. LaboratoryActivity displays feature flag sources next to them and allows users to select a source from a drop down menu. Remote feature flag values are displayed in LaboratoryActivity if a source is not local. When a remote source is used for a feature flag a value cannot be changed from LaboratoryActivity . LaboratoryActivity displays feature flag descriptions if they are present. LaboratoryActivity can reset feature flag values to their default state from an item in the action bar. Laboratory.experimentIs() and Laboratory.experimentIsBlocking() functions that allow to check if a feature flag has particular value. ViewPager2 1.0.0 dependency to laboratory-inspector . RecyclerView 1.1.0 dependency to laboratory-inspector .","title":"Added"},{"location":"changelog/#changed_21","text":"LaboratoryActivity requires now a Laboratory instance for initialization. This Laboratory should share FeatureStorage with instances of Laboratory used in the application.","title":"Changed"},{"location":"changelog/#050-2020-10-08","text":"","title":"0.5.0 - 2020-10-08"},{"location":"changelog/#changed_22","text":"fallback nomenclature to default . This affects Gradle plugin withFallbackValue() and withFallbackSources() functions as well as isFallbackValue property on the Feature interface.","title":"Changed"},{"location":"changelog/#040-2020-10-08","text":"","title":"0.4.0 - 2020-10-08"},{"location":"changelog/#changed_23","text":"Name of the generated sourced FeatureStorage extension function is now sourcedGenerated() in order to align it with the generated feature factory extension function name.","title":"Changed"},{"location":"changelog/#030-2020-10-08","text":"","title":"0.3.0 - 2020-10-08"},{"location":"changelog/#added_17","text":"Feature flags can have multiple sources. Source is also a feature flag and is optional. If no source is available it is assumed that only a local source is controlled. FeatureStorage that connects feature flags with their sources. It is available via FeatureStorage.sourced() extension function. Feature flag sources are uniquely identified only by their value names. Feature flag sources can be set from the Gradle plugin with withSource(\"Name\") and withFallbackSource(\"Name\") functions in feature() blocks. Any source that has the name \u201cLocal\u201d (or a variant of it) is filtered out. Gradle plugin has a new sourcedStorage() function. It is responsible for generating a customized FeatureStorage that is aware of all available feature flag sources. Gradle plugin has a new featureSourceFactory() function. It works similarly to featureFactory() function with a difference that it collects only feature flag sources. LaboratoryActivity is now configurable with the configure() function . LaboratoryActivity can display different sets of feature flags on separate tabs. FragmentKtx 1.2.5 dependency to laboratory-inspector . ViewModelKtx 2.2.0 dependency to laboratory-inspector .","title":"Added"},{"location":"changelog/#changed_24","text":"LaboratoryActivity.initialize() function is renamed to configure() . Gradle plugin factory() function is renamed to featureFactory() .","title":"Changed"},{"location":"changelog/#021-2020-10-02","text":"","title":"0.2.1 - 2020-10-02"},{"location":"changelog/#added_18","text":"Laboratory exposes a blocking way of reading and writing feature flags. It requires an opt-in BlockingIoCall annotation.","title":"Added"},{"location":"changelog/#changed_25","text":"laboratory-android artifact is now laboratory-shared-preferences artifact. laboratory-shared-preferences artifact (old laboratory-android ) is no longer automatically applied by Gradle plugin in Android modules. Upgrade to Kotlin 1.4.10 . Upgrade to CoreKtx 1.3.2 . Upgrade to Wire 3.4.0 . Upgrade to KotlinPoet 1.6.0 .","title":"Changed"},{"location":"changelog/#020-2020-09-05","text":"","title":"0.2.0 - 2020-09-05"},{"location":"changelog/#added_19","text":"Laboratory.observe() function to observe feature flag changes via Flow . Support for DataStore with the laboratory-data-store artifact. Laboratory and FeatureStorage return a boolean information whether writes are successful. Feature interface that is used to define feature flags. Wire 3.2.2 dependency to laboratory-data-store .","title":"Added"},{"location":"changelog/#changed_26","text":"Kotlin standard library is now part of the public API. Laboratory and FeatureStorage expose their API via suspend functions. Gradle plugin requires exactly one feature flag value to be added with withFallbackValue(\"Name\") function. Upgrade to Kotlin 1.4.0 . Upgrade to Material 1.2.1 . Upgrade to Hyperion 0.9.29 .","title":"Changed"},{"location":"changelog/#removed_7","text":"@Feature annotation. Feature flags should implement the Feature interface.","title":"Removed"},{"location":"changelog/#010-2020-08-03","text":"Initial release.","title":"0.1.0 - 2020-08-03"},{"location":"gradle-plugin/","text":"Gradle plugin \u00b6 Gradle plugin\u2019s main job is to make your life easier when creating and managing feature flags. It generates features, feature factories, and customized sourced feature storage. Plugin, additionally, verifies things that cannot be represented by the API. For example, it checks if a feature flag has exactly one default option defined. Under the hood, the Gradle plugin uses KotlinPoet to generate compact source files. Info The Gradle plugin automatically adds the laboratory artifact to dependencies. Tip The best way to understand the Gradle plugin is to check the samples . It uses most of the Gradle plugin features that most of the applications need. Feature flags \u00b6 Feature flags are added to the generation process with a feature() function, which uses the generateFeatureFlags Gradle task. Here is a sample configuration. Tip Check the sample with demo configuration. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" feature ( \"Authentication\" ) { description = \"Type of authentication when opening the app\" withOption ( \"None\" ) withOption ( \"Fingerprint\" ) withDefaultOption ( \"Retina\" ) } feature ( \"LocationTracking\" ) { packageName = \"io.mehow.laboratory.location\" isPublic = false withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withDefaultSource ( \"Firebase\" ) withSource ( \"Aws\" ) } } This setup creates two feature flags. Authentication and LocationTracking with options taken from the feature(name) { } block. Key things that might not be that obvious. Feature flag source visibility is inherited from a feature\u2019s visibility. If a feature flag defines a remote source, a Local source is automatically added as an option. Any custom Local sources will be filtered out. If all sources are added with withSource() function, Local source will be used as a default one. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import kotlin.Boolean import kotlin.String public enum class Authentication : Feature < Authentication > { Password , Fingerprint , Retina , ; public override val defaultOption get () = Retina public override val description : String = \"Type of authentication when opening the app\" } package io.mehow.laboratory.location import io.mehow.laboratory.Feature import java.lang.Class import kotlin.Boolean import kotlin.Suppress internal enum class LocationTracking : LocationTracking < Authentication > { Enabled , Disabled , ; public override val defaultOption get () = Disabled public override val source = Source :: class . java internal enum class Source : Feature < Source > { Local , Firebase , Aws , ; public override val defaultOption get () = Firebase } } Supervision \u00b6 Gradle plugin supports generation of supervised feature flags . Tip Check the sample with demo configuration. laboratory { feature ( \"ChristmasTheme\" ) { withDefaultOption ( \"Disabled\" ) withOption ( \"Enabled\" ) { enabledChristmas -> enabledChristmas . feature ( \"Greeting\" ) { greeting -> greeting . withDefaultOption ( \"Hello\" ) greeting . withOption ( \"HoHoHo\" ) } enabledChristmas . feature ( \"Background\" ) { background -> background . withDefaultOption ( \"White\" ) background . withOption ( \"Reindeer\" ) background . withOption ( \"Snowman\" ) } } } } This configuration generates the code below. enum class ChristmasTheme : Feature < ChristmasTheme > { Enabled , Disabled , ; public override val defaultOption get () = Disabled } enum class Greeting : Feature < Greeting > { Hello , HoHoHo , ; public override val defaultOption get () = Hello public override val supervisorOption get () = ChristmasTheme . Enabled } enum class Background : Feature < Background > { White , Reindeer , Snowman , ; public override val defaultOption get () = White public override val supervisorOption get () = ChristmasTheme . Enabled } DSL for supervised feature flags is recursive allowing to nest them in withOption() and withDefaultOption() functions. Feature flags storage \u00b6 If your feature flags use multiple sources, you can configure the Gradle plugin to generate for you a quality of life extension function that returns a custom FeatureStorage builder. Tip Check the sample with demo Firebase integration. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" sourcedStorage () feature ( \"FeatureA\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( \"Azure\" ) withSource ( \"Firebase\" ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( \"Azure\" ) withSource ( \"Aws\" ) } feature ( \"FeatureC\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( \"Heroku\" ) } feature ( \"FeatureD\" ) { withDefaultOption ( \"Enabled\" ) withOption ( \"Disabled\" ) } } sourcedBuilder() function uses generateSourcedFeatureStorage Gradle task that generates the code below. package io.mehow.laboratory.sample import io.mehow.laboratory.FeatureStorage import io.mehow.laboratory.FeatureStorage.Companion.sourced import kotlin.String import kotlin.collections.Map import kotlin.collections.emptyMap import kotlin.collections.plus import kotlin.to internal fun FeatureStorage . Companion . sourcedBuilder ( localSource : FeatureStorage ): AwsStep = Builder ( localSource , emptyMap ()) internal interface AwsStep { public fun awsSource ( source : FeatureStorage ): AzureStep } internal interface AzureStep { public fun azureSource ( source : FeatureStorage ): FirebaseStep } internal interface FirebaseStep { public fun firebaseSource ( source : FeatureStorage ): HerokuStep } internal interface HerokuStep { public fun herokuSource ( source : FeatureStorage ): BuildingStep } internal interface BuildingStep { public fun build (): FeatureStorage } private data class Builder ( private val localSource : FeatureStorage , private val remoteSources : Map < String , FeatureStorage > ) : AwsStep , AzureStep , FirebaseStep , HerokuStep , BuildingStep { public override fun awsSourceSource ( source : FeatureStorage ): AzureStep = copy ( remoteSources = remoteSources + ( \"Firebase\" to source ) ) public override fun azureSource ( source : FeatureStorage ): FirebaseStep = copy ( remoteSources = remoteSources + ( \"Azure\" to source ) ) public override fun firebaseSource ( source : FeatureStorage ): HerokuStep = copy ( remoteSources = remoteSources + ( \"Firebase\" to source ) ) public override fun herokuSource ( source : FeatureStorage ): BuildingStep = copy ( remoteSources = remoteSources + ( \"Heroku\" to source ) ) public override fun build (): FeatureStorage = sourced ( localSource , remoteSources ) } Feature flags factory \u00b6 The generation of feature flags factory is useful if you use the QA module . Tip Check the samples with demo configurations. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" featureFactory () feature ( \"FeatureA\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureC\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } } featureFactory() uses generateFeatureFactory Gradle task that generates the code below. Class.forname() is used for lookup instead of the direct reference to classes because there is no guarantee that feature flags are directly available in the module that generates the factory if feature flags come, for example, as transitive dependencies of other modules. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import io.mehow.laboratory.FeatureFactory import java.lang.Class import kotlin.Suppress import kotlin.collections.Set import kotlin.collections.setOf internal fun FeatureFactory . Companion . featureGenerated (): FeatureFactory = GeneratedFeatureFactory private object GeneratedFeatureFactory : FeatureFactory { @Suppress ( \"UNCHECKED_CAST\" ) override fun create (): Set < Class < out Feature <*>>> = setOf ( Class . forName ( \"io.mehow.laboratory.sample.FeatureA\" ), Class . forName ( \"io.mehow.laboratory.sample.FeatureB\" ), Class . forName ( \"io.mehow.laboratory.sample.FeatureC\" ) ) as Set < Class < Feature <*>>> } Feature flag sources factory \u00b6 If you want to group all feature flag sources similar to feature flags, you can use featureSourceFactory() function that collects them. laboratory { packageName = \"io.mehow.laboratory.sample\" featureSourceFactory () feature ( \"FeatureA\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( Remote ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( Remote ) } } This uses the generateFeatureSourceFactory Gradle task that generates the code below. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import io.mehow.laboratory.FeatureFactory import java.lang.Class import kotlin.Suppress import kotlin.collections.Set import kotlin.collections.setOf internal fun FeatureFactory . Companion . featureSourceGenerated (): FeatureFactory = GeneratedFeatureSourceFactory private object GeneratedFeatureSourceFactory : FeatureFactory { @Suppress ( \"UNCHECKED_CAST\" ) override fun create (): Set < Class < out Feature <*>>> = setOf ( Class . forName ( \"io.mehow.laboratory.sample.FeatureA ${ '$' } Source\" ), Class . forName ( \"io.mehow.laboratory.sample.FeatureB ${ '$' } Source\" ) ) as Set < Class < Feature <*>>> } Feature flag option factory \u00b6 The generation of an option factory is useful when you want to control local feature flag options remotely. Option factory aggregates all feature flags and recognizes them either by a fully qualified class name or an optional key property on a feature flag. Keys must be unique and cannot match fully qualified class names of other feature flags. Tip Check the sample with demo Firebase integration. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" optionFactory () feature ( \"FeatureA\" ) { key = \"FeatureA\" withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureC\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } } This uses the generateOptionFactory Gradle task that generates the code below. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import io.mehow.laboratory.OptionFactory internal fun OptionFactory . Companion . generated (): OptionFactory = GeneratedOptionFactory private object GeneratedOptionFactory : OptionFactory { override fun create ( key : String , name : String ): Feature <*>? = when ( key ) { \"FeatureA\" -> when ( name ) { \"Enabled\" -> FeatureA . Enabled \"Disabled\" -> FeatureA . Disabled else -> null } \"io.mehow.laboratory.sample.FeatureB\" -> when ( name ) { \"Enabled\" -> FeatureB . Enabled \"Disabled\" -> FeatureB . Disabled else -> null } \"io.mehow.laboratory.sample.FeatureC\" -> when ( name ) { \"Enabled\" -> FeatureC . Enabled \"Disabled\" -> FeatureC . Disabled else -> null } else -> null } } Multi-module support \u00b6 The Gradle plugin was written with support for multi-module projects in mind. Tip Check the sample with demo configuration. . \u251c\u2500 module-a \u2502 \u2514\u2500 build.gradle \u251c\u2500 module-b \u2502 \u2514\u2500 build.gradle \u251c\u2500 module-app \u2502 \u2514\u2500 build.gradle \u251c\u2500 build.gradle \u2514\u2500 settings.gradle A Laboratory setup for a Gradle project like above could look like this. Configuration of the Android Gradle plugin or any other dependencies is omitted for brevity. // module-a plugins { id \"org.jetbrains.kotlin.jvm\" id \"io.mehow.laboratory\" } laboratory { packageName = \"com.sample.a\" feature ( \"Authentication\" ) { withDefaultOption ( \"Password\" ) withOption ( \"Fingerprint\" ) withOption ( \"Retina\" ) withOption ( \"Face\" ) withSource ( \"Firebase\" ) withSource ( \"Aws\" ) } feature ( \"AllowScreenshots\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } } // module-b plugins { id \"org.jetbrains.kotlin.jvm\" id \"io.mehow.laboratory\" } laboratory { packageName = \"com.sample.b\" feature ( \"DistanceAlgorithm\" ) { isPublic = false withDefaultOption ( \"Euclidean\" ) withOption ( \"Jaccard\" ) withOption ( \"Cosine\" ) withOption ( \"Edit\" ) withOption ( \"Hamming\" ) withSource ( \"Firebase\" ) withDefaultSource ( \"Azure\" ) } } dependencies { implementation project ( \":module-a\" ) } // module-app plugins { id \"com.android.application\" id \"org.jetbrains.kotlin.android\" id \"io.mehow.laboratory\" } laboratory { packageName = \"com.sample\" sourcedStorage () featureFactory () dependency ( project ( \":module-a\" )) dependency ( project ( \":module-b\" )) } dependencies { implementation project ( \":module-b\" ) } This setup shows that each module can define its feature flags that do not have to be exposed outside. In this scenario, module-app is responsible only for gluing together all feature flags so that Laboratory instances are aware of feature flag sources and the QA module . It should then deliver the correct Laboratory to modules via dependency injection. In order to include feature flags during generation of factories, their modules need to be added with dependency function. Full configuration \u00b6 Below is the full configuration of the Gradle plugins. laboratory { // Sets namespace of generated features and factories. Empty by default. packageName = \"io.mehow.sample\" // Informs plugin to create 'enum class SomeFeature' during the generation period. feature ( \"SomeFeature\" ) { // Used for option factory lookup. No value by default. key = \"SomeFeatureKey\" // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.feature\" // Adds a description to this feature that can be used for more context. description = \"Feature description\" // Sets the visibility of a feature flag to be either 'public' or 'internal'. 'true' by default. isPublic = false // Deprecates a feature flag. `DeprecationLevel` argument is optional and uses `DeprecationLevel.Warning` by default. // Add the class to the import list in your Gradle script to avoid typing the whole package name. deprecated ( \"Deprecation message\" , io . mehow . laboratory . gradle . DeprecationLevel . Hidden ) // Informs plugin to add 'ValueA' option to the generated feature flag and set it as a default option. // Exactly one of the feature options must be set with this function. withDefaultOption ( \"ValueA\" ) // Informs plugin to add 'ValueB' option to the generated feature flag. withOption ( \"ValueB\" ) // Informs plugin to add 'Firebase' option to the list of sources controlling this flag. // Adding any source automatically adds the 'Local' option to the source enum. // Any custom 'Local' sources are ignored by the plugin. withSource ( \"Firebase\" ) // Informs plugin to add 'Aws' option to the list of sources controlling this flag and to set a default option. // At most, one of the source options can be set with this function. // By default, 'Local' sources are considered to be default options. withDefaultSource ( \"Aws\" ) // Same as `withDefaultOption(option)` without lambda except that it generates supervised feature flags // defined in the lambda. withDefaultOption ( \"Option\" ) { option -> option . feature ( \"SupervisedFeature\" ) { // recursive feature generation } } // Same as `withOption(option)` without lambda except that it generates supervised feature flags // defined in the lambda. withOption ( \"Option\" ) { option -> option . feature ( \"SupervisedFeature\" ) { // recursive feature generation } } } // Configures feature flags storage. Useful when feature flags have multiple sources. sourcedStorage { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.storage\" // Sets visibility of a storage extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Configures option factory. Useful for integration with remote service such as Firebase. optionFactory { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.factory\" // Sets visibility of a factory extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Configures feature flags factory. Useful for the QA module configuration. featureFactory { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.factory\" // Sets visibility of a factory extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Configures feature flag sources factory. featureSourceFactory { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.factory\" // Sets visibility of a factory extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Includes feature flags that are used for generation of feature factories, sourced storage and option factory. dependency ( project ( \":some-project\" )) }","title":"Gradle plugin"},{"location":"gradle-plugin/#gradle-plugin","text":"Gradle plugin\u2019s main job is to make your life easier when creating and managing feature flags. It generates features, feature factories, and customized sourced feature storage. Plugin, additionally, verifies things that cannot be represented by the API. For example, it checks if a feature flag has exactly one default option defined. Under the hood, the Gradle plugin uses KotlinPoet to generate compact source files. Info The Gradle plugin automatically adds the laboratory artifact to dependencies. Tip The best way to understand the Gradle plugin is to check the samples . It uses most of the Gradle plugin features that most of the applications need.","title":"Gradle plugin"},{"location":"gradle-plugin/#feature-flags","text":"Feature flags are added to the generation process with a feature() function, which uses the generateFeatureFlags Gradle task. Here is a sample configuration. Tip Check the sample with demo configuration. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" feature ( \"Authentication\" ) { description = \"Type of authentication when opening the app\" withOption ( \"None\" ) withOption ( \"Fingerprint\" ) withDefaultOption ( \"Retina\" ) } feature ( \"LocationTracking\" ) { packageName = \"io.mehow.laboratory.location\" isPublic = false withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withDefaultSource ( \"Firebase\" ) withSource ( \"Aws\" ) } } This setup creates two feature flags. Authentication and LocationTracking with options taken from the feature(name) { } block. Key things that might not be that obvious. Feature flag source visibility is inherited from a feature\u2019s visibility. If a feature flag defines a remote source, a Local source is automatically added as an option. Any custom Local sources will be filtered out. If all sources are added with withSource() function, Local source will be used as a default one. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import kotlin.Boolean import kotlin.String public enum class Authentication : Feature < Authentication > { Password , Fingerprint , Retina , ; public override val defaultOption get () = Retina public override val description : String = \"Type of authentication when opening the app\" } package io.mehow.laboratory.location import io.mehow.laboratory.Feature import java.lang.Class import kotlin.Boolean import kotlin.Suppress internal enum class LocationTracking : LocationTracking < Authentication > { Enabled , Disabled , ; public override val defaultOption get () = Disabled public override val source = Source :: class . java internal enum class Source : Feature < Source > { Local , Firebase , Aws , ; public override val defaultOption get () = Firebase } }","title":"Feature flags"},{"location":"gradle-plugin/#supervision","text":"Gradle plugin supports generation of supervised feature flags . Tip Check the sample with demo configuration. laboratory { feature ( \"ChristmasTheme\" ) { withDefaultOption ( \"Disabled\" ) withOption ( \"Enabled\" ) { enabledChristmas -> enabledChristmas . feature ( \"Greeting\" ) { greeting -> greeting . withDefaultOption ( \"Hello\" ) greeting . withOption ( \"HoHoHo\" ) } enabledChristmas . feature ( \"Background\" ) { background -> background . withDefaultOption ( \"White\" ) background . withOption ( \"Reindeer\" ) background . withOption ( \"Snowman\" ) } } } } This configuration generates the code below. enum class ChristmasTheme : Feature < ChristmasTheme > { Enabled , Disabled , ; public override val defaultOption get () = Disabled } enum class Greeting : Feature < Greeting > { Hello , HoHoHo , ; public override val defaultOption get () = Hello public override val supervisorOption get () = ChristmasTheme . Enabled } enum class Background : Feature < Background > { White , Reindeer , Snowman , ; public override val defaultOption get () = White public override val supervisorOption get () = ChristmasTheme . Enabled } DSL for supervised feature flags is recursive allowing to nest them in withOption() and withDefaultOption() functions.","title":"Supervision"},{"location":"gradle-plugin/#feature-flags-storage","text":"If your feature flags use multiple sources, you can configure the Gradle plugin to generate for you a quality of life extension function that returns a custom FeatureStorage builder. Tip Check the sample with demo Firebase integration. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" sourcedStorage () feature ( \"FeatureA\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( \"Azure\" ) withSource ( \"Firebase\" ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( \"Azure\" ) withSource ( \"Aws\" ) } feature ( \"FeatureC\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( \"Heroku\" ) } feature ( \"FeatureD\" ) { withDefaultOption ( \"Enabled\" ) withOption ( \"Disabled\" ) } } sourcedBuilder() function uses generateSourcedFeatureStorage Gradle task that generates the code below. package io.mehow.laboratory.sample import io.mehow.laboratory.FeatureStorage import io.mehow.laboratory.FeatureStorage.Companion.sourced import kotlin.String import kotlin.collections.Map import kotlin.collections.emptyMap import kotlin.collections.plus import kotlin.to internal fun FeatureStorage . Companion . sourcedBuilder ( localSource : FeatureStorage ): AwsStep = Builder ( localSource , emptyMap ()) internal interface AwsStep { public fun awsSource ( source : FeatureStorage ): AzureStep } internal interface AzureStep { public fun azureSource ( source : FeatureStorage ): FirebaseStep } internal interface FirebaseStep { public fun firebaseSource ( source : FeatureStorage ): HerokuStep } internal interface HerokuStep { public fun herokuSource ( source : FeatureStorage ): BuildingStep } internal interface BuildingStep { public fun build (): FeatureStorage } private data class Builder ( private val localSource : FeatureStorage , private val remoteSources : Map < String , FeatureStorage > ) : AwsStep , AzureStep , FirebaseStep , HerokuStep , BuildingStep { public override fun awsSourceSource ( source : FeatureStorage ): AzureStep = copy ( remoteSources = remoteSources + ( \"Firebase\" to source ) ) public override fun azureSource ( source : FeatureStorage ): FirebaseStep = copy ( remoteSources = remoteSources + ( \"Azure\" to source ) ) public override fun firebaseSource ( source : FeatureStorage ): HerokuStep = copy ( remoteSources = remoteSources + ( \"Firebase\" to source ) ) public override fun herokuSource ( source : FeatureStorage ): BuildingStep = copy ( remoteSources = remoteSources + ( \"Heroku\" to source ) ) public override fun build (): FeatureStorage = sourced ( localSource , remoteSources ) }","title":"Feature flags storage"},{"location":"gradle-plugin/#feature-flags-factory","text":"The generation of feature flags factory is useful if you use the QA module . Tip Check the samples with demo configurations. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" featureFactory () feature ( \"FeatureA\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureC\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } } featureFactory() uses generateFeatureFactory Gradle task that generates the code below. Class.forname() is used for lookup instead of the direct reference to classes because there is no guarantee that feature flags are directly available in the module that generates the factory if feature flags come, for example, as transitive dependencies of other modules. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import io.mehow.laboratory.FeatureFactory import java.lang.Class import kotlin.Suppress import kotlin.collections.Set import kotlin.collections.setOf internal fun FeatureFactory . Companion . featureGenerated (): FeatureFactory = GeneratedFeatureFactory private object GeneratedFeatureFactory : FeatureFactory { @Suppress ( \"UNCHECKED_CAST\" ) override fun create (): Set < Class < out Feature <*>>> = setOf ( Class . forName ( \"io.mehow.laboratory.sample.FeatureA\" ), Class . forName ( \"io.mehow.laboratory.sample.FeatureB\" ), Class . forName ( \"io.mehow.laboratory.sample.FeatureC\" ) ) as Set < Class < Feature <*>>> }","title":"Feature flags factory"},{"location":"gradle-plugin/#feature-flag-sources-factory","text":"If you want to group all feature flag sources similar to feature flags, you can use featureSourceFactory() function that collects them. laboratory { packageName = \"io.mehow.laboratory.sample\" featureSourceFactory () feature ( \"FeatureA\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( Remote ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) withSource ( Remote ) } } This uses the generateFeatureSourceFactory Gradle task that generates the code below. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import io.mehow.laboratory.FeatureFactory import java.lang.Class import kotlin.Suppress import kotlin.collections.Set import kotlin.collections.setOf internal fun FeatureFactory . Companion . featureSourceGenerated (): FeatureFactory = GeneratedFeatureSourceFactory private object GeneratedFeatureSourceFactory : FeatureFactory { @Suppress ( \"UNCHECKED_CAST\" ) override fun create (): Set < Class < out Feature <*>>> = setOf ( Class . forName ( \"io.mehow.laboratory.sample.FeatureA ${ '$' } Source\" ), Class . forName ( \"io.mehow.laboratory.sample.FeatureB ${ '$' } Source\" ) ) as Set < Class < Feature <*>>> }","title":"Feature flag sources factory"},{"location":"gradle-plugin/#feature-flag-option-factory","text":"The generation of an option factory is useful when you want to control local feature flag options remotely. Option factory aggregates all feature flags and recognizes them either by a fully qualified class name or an optional key property on a feature flag. Keys must be unique and cannot match fully qualified class names of other feature flags. Tip Check the sample with demo Firebase integration. apply plugin: \"io.mehow.laboratory\" laboratory { packageName = \"io.mehow.laboratory.sample\" optionFactory () feature ( \"FeatureA\" ) { key = \"FeatureA\" withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureB\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } feature ( \"FeatureC\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } } This uses the generateOptionFactory Gradle task that generates the code below. package io.mehow.laboratory.sample import io.mehow.laboratory.Feature import io.mehow.laboratory.OptionFactory internal fun OptionFactory . Companion . generated (): OptionFactory = GeneratedOptionFactory private object GeneratedOptionFactory : OptionFactory { override fun create ( key : String , name : String ): Feature <*>? = when ( key ) { \"FeatureA\" -> when ( name ) { \"Enabled\" -> FeatureA . Enabled \"Disabled\" -> FeatureA . Disabled else -> null } \"io.mehow.laboratory.sample.FeatureB\" -> when ( name ) { \"Enabled\" -> FeatureB . Enabled \"Disabled\" -> FeatureB . Disabled else -> null } \"io.mehow.laboratory.sample.FeatureC\" -> when ( name ) { \"Enabled\" -> FeatureC . Enabled \"Disabled\" -> FeatureC . Disabled else -> null } else -> null } }","title":"Feature flag option factory"},{"location":"gradle-plugin/#multi-module-support","text":"The Gradle plugin was written with support for multi-module projects in mind. Tip Check the sample with demo configuration. . \u251c\u2500 module-a \u2502 \u2514\u2500 build.gradle \u251c\u2500 module-b \u2502 \u2514\u2500 build.gradle \u251c\u2500 module-app \u2502 \u2514\u2500 build.gradle \u251c\u2500 build.gradle \u2514\u2500 settings.gradle A Laboratory setup for a Gradle project like above could look like this. Configuration of the Android Gradle plugin or any other dependencies is omitted for brevity. // module-a plugins { id \"org.jetbrains.kotlin.jvm\" id \"io.mehow.laboratory\" } laboratory { packageName = \"com.sample.a\" feature ( \"Authentication\" ) { withDefaultOption ( \"Password\" ) withOption ( \"Fingerprint\" ) withOption ( \"Retina\" ) withOption ( \"Face\" ) withSource ( \"Firebase\" ) withSource ( \"Aws\" ) } feature ( \"AllowScreenshots\" ) { withOption ( \"Enabled\" ) withDefaultOption ( \"Disabled\" ) } } // module-b plugins { id \"org.jetbrains.kotlin.jvm\" id \"io.mehow.laboratory\" } laboratory { packageName = \"com.sample.b\" feature ( \"DistanceAlgorithm\" ) { isPublic = false withDefaultOption ( \"Euclidean\" ) withOption ( \"Jaccard\" ) withOption ( \"Cosine\" ) withOption ( \"Edit\" ) withOption ( \"Hamming\" ) withSource ( \"Firebase\" ) withDefaultSource ( \"Azure\" ) } } dependencies { implementation project ( \":module-a\" ) } // module-app plugins { id \"com.android.application\" id \"org.jetbrains.kotlin.android\" id \"io.mehow.laboratory\" } laboratory { packageName = \"com.sample\" sourcedStorage () featureFactory () dependency ( project ( \":module-a\" )) dependency ( project ( \":module-b\" )) } dependencies { implementation project ( \":module-b\" ) } This setup shows that each module can define its feature flags that do not have to be exposed outside. In this scenario, module-app is responsible only for gluing together all feature flags so that Laboratory instances are aware of feature flag sources and the QA module . It should then deliver the correct Laboratory to modules via dependency injection. In order to include feature flags during generation of factories, their modules need to be added with dependency function.","title":"Multi-module support"},{"location":"gradle-plugin/#full-configuration","text":"Below is the full configuration of the Gradle plugins. laboratory { // Sets namespace of generated features and factories. Empty by default. packageName = \"io.mehow.sample\" // Informs plugin to create 'enum class SomeFeature' during the generation period. feature ( \"SomeFeature\" ) { // Used for option factory lookup. No value by default. key = \"SomeFeatureKey\" // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.feature\" // Adds a description to this feature that can be used for more context. description = \"Feature description\" // Sets the visibility of a feature flag to be either 'public' or 'internal'. 'true' by default. isPublic = false // Deprecates a feature flag. `DeprecationLevel` argument is optional and uses `DeprecationLevel.Warning` by default. // Add the class to the import list in your Gradle script to avoid typing the whole package name. deprecated ( \"Deprecation message\" , io . mehow . laboratory . gradle . DeprecationLevel . Hidden ) // Informs plugin to add 'ValueA' option to the generated feature flag and set it as a default option. // Exactly one of the feature options must be set with this function. withDefaultOption ( \"ValueA\" ) // Informs plugin to add 'ValueB' option to the generated feature flag. withOption ( \"ValueB\" ) // Informs plugin to add 'Firebase' option to the list of sources controlling this flag. // Adding any source automatically adds the 'Local' option to the source enum. // Any custom 'Local' sources are ignored by the plugin. withSource ( \"Firebase\" ) // Informs plugin to add 'Aws' option to the list of sources controlling this flag and to set a default option. // At most, one of the source options can be set with this function. // By default, 'Local' sources are considered to be default options. withDefaultSource ( \"Aws\" ) // Same as `withDefaultOption(option)` without lambda except that it generates supervised feature flags // defined in the lambda. withDefaultOption ( \"Option\" ) { option -> option . feature ( \"SupervisedFeature\" ) { // recursive feature generation } } // Same as `withOption(option)` without lambda except that it generates supervised feature flags // defined in the lambda. withOption ( \"Option\" ) { option -> option . feature ( \"SupervisedFeature\" ) { // recursive feature generation } } } // Configures feature flags storage. Useful when feature flags have multiple sources. sourcedStorage { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.storage\" // Sets visibility of a storage extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Configures option factory. Useful for integration with remote service such as Firebase. optionFactory { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.factory\" // Sets visibility of a factory extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Configures feature flags factory. Useful for the QA module configuration. featureFactory { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.factory\" // Sets visibility of a factory extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Configures feature flag sources factory. featureSourceFactory { // Overrides globally declared namespace. No value by default. packageName = \"io.mehow.sample.factory\" // Sets visibility of a factory extension function to be either 'public' or 'internal'. 'false' by default. isPublic = true } // Includes feature flags that are used for generation of feature factories, sourced storage and option factory. dependency ( project ( \":some-project\" )) }","title":"Full configuration"},{"location":"qa-module/","text":"QA module \u00b6 It is very often desirable to have the option of configuring feature flag options at runtime. Laboratory addresses this problem with its QA modules. Inspector \u00b6 Feature flags inspection is available through the laboratory-inspector artifact. LaboratoryActivity is an Activity that enables inspection and modifications of feature flags. Inspector displays feature flags as cards and their options on chips. Active options of feature flags are marked with a highlight color. A local option of a feature flag can be changed by tapping on a chip. Chips that do not use Local sources cannot have their options changed. If a feature flag has multiple sources available, they can be switched from a drop down menu. Feature flags (including sources) can be reset to their default options with a button in an action bar. Configuration \u00b6 Before LaboratoryActivity can be started, it has to be configured with an instance of Laboratory and at least one instance of FeatureFactory . FeatureFactory is an interface that should gather feature flags that are logically grouped together. Logical grouping can be different for each application, but in most cases, all feature flags in the project belong to a single unit. Scenarios, when you might want to split feature flags, are for example: Feature flags that do not belong to your project and are exposed to you from an external library. Abundance of feature flags and a need to increase the readability of the inspector interface by separating feature flags into custom categories. Tip A lot of the boilerplate code presented here can be generated with the Gradle plugin . It is highly recommended to rely on the plugin instead of handwriting the code. val sourcedFeatureStorage = FeatureStorage . sourced ( localSource = FeatureStorage . inMemory (), remoteSources = mapOf ( \"Firebase\" to FeatureStorage . inMemory (), \"Aws\" to FeatureStorage . inMemory (), \"Azure\" to FeatureStorage . inMemory (), ), ) val laboratory = Laboratory . create ( sourcedFeatureStorage ) LaboratoryActivity . configure ( laboratory = laboratory , featureFactory = CustomFeatureFactory , ) LaboratoryActivity . start ( context ) object CustomFeatureFactory : FeatureFactory { override fun create (): Set < Class < out Feature <*>>> = setOf ( AllowScreenshots :: class . java , Authentication :: class . java , PowerSource :: class . java , DistanceAlgorithm :: class . java , LogType :: class . java , ) } enum class AllowScreenshots : Feature < AllowScreenshots > { Enabled , Disabled ; public override val defaultOption get () = Disabled override val description : String = \"Enables or disables screenshots during a video chat\" } enum class Authentication : Feature < Authentication > { Password , Fingerprint , Retina , Face ; public override val defaultOption get () = Password override val source = Source :: class . java enum class Source : Feature < Source > { Local , Firebase , Aws ; public override val defaultOption get () = Local } } enum class DistanceAlgorithm : Feature < DistanceAlgorithm > { Euclidean , Jaccard , Cosine , Edit , Hamming ; public override val defaultOption get () = Euclidean @Suppress ( \"UNCHECKED_CAST\" ) override val source : Class < Feature <*>> = Source :: class . java as Class < Feature <*>> override val description : String = \"Algorithm used for destination distance calculations\" enum class Source : Feature < Source > { Local , Firebase , Azure ; public override val defaultOption get () = Azure } } enum class LogType : Feature < LogType > { Verbose , Debug , Info , Warning , Error ; public override val defaultOption get () = Info } enum class PowerSource : Feature < PowerSource > { Coal , Wind , Solar , Nuclear , ColdFusion ; public override val defaultOption get () = Solar @Suppress ( \"UNCHECKED_CAST\" ) override val source : Class < Feature <*>> = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Firebase ; public override val defaultOption get () = Firebase } } Deprecation \u00b6 You can configure how deprecated feature flags will be represented in the QA module. To do this you need to pass additional parameters to the Configuration builder. val configuration = LaboratoryActivity . Configuration . builder () . laboratory ( laboratory ) . featureFactories ( mapOf ( \"Features\" to featureFactory )) . deprecationPhenotypeSelector { deprecationLevel -> DeprecationPhenotype . Strikethrough } . deprecationAlignmentSelector { deprecationLevel -> DeprecationAlignment . Bottom } . build () LaboratoryActivity . configure ( configuration ) Hyperion \u00b6 If you use Hyperion you can easily integrate Laboratory by adding the laboratory-hyperion-plugin artifact to your dependencies. This will put an item in Hyperion\u2019s debug menu. If you\u2019d like to position the Laboratory menu item in a different place on the menu, you can override the string id resource. <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string name= \"io_mehow_laboratory_plugin_id\" translatable= \"false\" > !Laboratory </string> </resources>","title":"QA module"},{"location":"qa-module/#qa-module","text":"It is very often desirable to have the option of configuring feature flag options at runtime. Laboratory addresses this problem with its QA modules.","title":"QA module"},{"location":"qa-module/#inspector","text":"Feature flags inspection is available through the laboratory-inspector artifact. LaboratoryActivity is an Activity that enables inspection and modifications of feature flags. Inspector displays feature flags as cards and their options on chips. Active options of feature flags are marked with a highlight color. A local option of a feature flag can be changed by tapping on a chip. Chips that do not use Local sources cannot have their options changed. If a feature flag has multiple sources available, they can be switched from a drop down menu. Feature flags (including sources) can be reset to their default options with a button in an action bar.","title":"Inspector"},{"location":"qa-module/#configuration","text":"Before LaboratoryActivity can be started, it has to be configured with an instance of Laboratory and at least one instance of FeatureFactory . FeatureFactory is an interface that should gather feature flags that are logically grouped together. Logical grouping can be different for each application, but in most cases, all feature flags in the project belong to a single unit. Scenarios, when you might want to split feature flags, are for example: Feature flags that do not belong to your project and are exposed to you from an external library. Abundance of feature flags and a need to increase the readability of the inspector interface by separating feature flags into custom categories. Tip A lot of the boilerplate code presented here can be generated with the Gradle plugin . It is highly recommended to rely on the plugin instead of handwriting the code. val sourcedFeatureStorage = FeatureStorage . sourced ( localSource = FeatureStorage . inMemory (), remoteSources = mapOf ( \"Firebase\" to FeatureStorage . inMemory (), \"Aws\" to FeatureStorage . inMemory (), \"Azure\" to FeatureStorage . inMemory (), ), ) val laboratory = Laboratory . create ( sourcedFeatureStorage ) LaboratoryActivity . configure ( laboratory = laboratory , featureFactory = CustomFeatureFactory , ) LaboratoryActivity . start ( context ) object CustomFeatureFactory : FeatureFactory { override fun create (): Set < Class < out Feature <*>>> = setOf ( AllowScreenshots :: class . java , Authentication :: class . java , PowerSource :: class . java , DistanceAlgorithm :: class . java , LogType :: class . java , ) } enum class AllowScreenshots : Feature < AllowScreenshots > { Enabled , Disabled ; public override val defaultOption get () = Disabled override val description : String = \"Enables or disables screenshots during a video chat\" } enum class Authentication : Feature < Authentication > { Password , Fingerprint , Retina , Face ; public override val defaultOption get () = Password override val source = Source :: class . java enum class Source : Feature < Source > { Local , Firebase , Aws ; public override val defaultOption get () = Local } } enum class DistanceAlgorithm : Feature < DistanceAlgorithm > { Euclidean , Jaccard , Cosine , Edit , Hamming ; public override val defaultOption get () = Euclidean @Suppress ( \"UNCHECKED_CAST\" ) override val source : Class < Feature <*>> = Source :: class . java as Class < Feature <*>> override val description : String = \"Algorithm used for destination distance calculations\" enum class Source : Feature < Source > { Local , Firebase , Azure ; public override val defaultOption get () = Azure } } enum class LogType : Feature < LogType > { Verbose , Debug , Info , Warning , Error ; public override val defaultOption get () = Info } enum class PowerSource : Feature < PowerSource > { Coal , Wind , Solar , Nuclear , ColdFusion ; public override val defaultOption get () = Solar @Suppress ( \"UNCHECKED_CAST\" ) override val source : Class < Feature <*>> = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Firebase ; public override val defaultOption get () = Firebase } }","title":"Configuration"},{"location":"qa-module/#deprecation","text":"You can configure how deprecated feature flags will be represented in the QA module. To do this you need to pass additional parameters to the Configuration builder. val configuration = LaboratoryActivity . Configuration . builder () . laboratory ( laboratory ) . featureFactories ( mapOf ( \"Features\" to featureFactory )) . deprecationPhenotypeSelector { deprecationLevel -> DeprecationPhenotype . Strikethrough } . deprecationAlignmentSelector { deprecationLevel -> DeprecationAlignment . Bottom } . build () LaboratoryActivity . configure ( configuration )","title":"Deprecation"},{"location":"qa-module/#hyperion","text":"If you use Hyperion you can easily integrate Laboratory by adding the laboratory-hyperion-plugin artifact to your dependencies. This will put an item in Hyperion\u2019s debug menu. If you\u2019d like to position the Laboratory menu item in a different place on the menu, you can override the string id resource. <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string name= \"io_mehow_laboratory_plugin_id\" translatable= \"false\" > !Laboratory </string> </resources>","title":"Hyperion"},{"location":"releasing/","text":"Releasing \u00b6 Versioning \u00b6 Run the prepare release script and bump the desirable version part. If there are no errors git push && git push --tags . Wait for the CI server to upload the artifacts. Visit Sonatype Nexus and promote the artifacts. Documentation updates \u00b6 Website documentation lives under /library/docs directory and is deployed with MkDocs using Material Theme . A new site is built and published for the latest commits on the trunk branch. If you want to test the website locally before pushing changes, you need to follow these steps. Make sure you have Python 3 and pip installed. $ python --version Python 3 .8.5 $ pip --version pip 20 .2.4 Install MkDocs, Material Theme and MkDocs Video. $ pip install mkdocs mkdocs-material mkdocs-video $ mkdocs --version mkdocs, version 1 .1.2 Navigate to the library directory and run the site locally. $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0 .73 seconds [ I 201026 22 :51:56 server:335 ] Serving on http://127.0.0.1:8000 INFO - Serving on http://127.0.0.1:8000","title":"Releasing"},{"location":"releasing/#releasing","text":"","title":"Releasing"},{"location":"releasing/#versioning","text":"Run the prepare release script and bump the desirable version part. If there are no errors git push && git push --tags . Wait for the CI server to upload the artifacts. Visit Sonatype Nexus and promote the artifacts.","title":"Versioning"},{"location":"releasing/#documentation-updates","text":"Website documentation lives under /library/docs directory and is deployed with MkDocs using Material Theme . A new site is built and published for the latest commits on the trunk branch. If you want to test the website locally before pushing changes, you need to follow these steps. Make sure you have Python 3 and pip installed. $ python --version Python 3 .8.5 $ pip --version pip 20 .2.4 Install MkDocs, Material Theme and MkDocs Video. $ pip install mkdocs mkdocs-material mkdocs-video $ mkdocs --version mkdocs, version 1 .1.2 Navigate to the library directory and run the site locally. $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0 .73 seconds [ I 201026 22 :51:56 server:335 ] Serving on http://127.0.0.1:8000 INFO - Serving on http://127.0.0.1:8000","title":"Documentation updates"},{"location":"user-guide/","text":"User guide \u00b6 Features \u00b6 Feature flags are nothing more than enums that implement the Feature interface. It allows us to define a default option, remote sources that can provide different options and descriptions for some human-readable metadata. Danger Feature enums must have at least one option. Defining an enum like below will make Laboratory throw an exception when used to read an option. enum class SomeFeature : Feature < SomeFeature > Tip Check the samples to learn by example. I/O \u00b6 Laboratory is nothing more than a high-level API over the FeatureStorage interface responsible for persisting feature flags. All implementations that are provided by this library rely on a feature flag package name and an enum name. Warning Because the persistence mechanism relies on package names and enum names, you should be careful when refactoring feature flags already available on production. Changing these options may result in a perception of unsaved feature flags. Because FeatureStorage is an interface that is meant to be used with I/O operations, it exposes only suspend functions. Laboratory , on the other hand, allows you to opt-into blocking equivalents of read and write functions. You can selectively do this by applying the @BlockingIoCall annotation or globally by adding a compiler flag. android { kotlinOptions { freeCompilerArgs += [ \"-Xopt-in=io.mehow.laboratory.BlockingIoCall\" , ] } } In either case, a design that relies on non-blocking function calls is preferable. Sources \u00b6 Feature flags, by default, have only a single source for their options. By convention, it is considered to be a local source. However, you might need to have different data sources for feature flags, depending on some runtime conditions or a build variant. For example, you might want to use a local source during debugging and rely on some remote services on production. Let\u2019s say that you want to have a feature flag that has three sources. One local, and two remote ones. Info Notice that a feature flag source is also a feature flag. This allows us to change feature flag sources via Laboratory as well. enum class PowerType : Feature < PowerType > { Coal , Wind , Solar ; public override val defaultOption get () = Solar @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Firebase , Azure ; public override val defaultOption get () = Firebase } } If you define multiple sources for a feature flag, you should add a Local option to them. This allows changing feature flag options at runtime from the QA module . This feature flag definition allows configuring Laboratory in a way that it is capable of recognizing that PowerType has different option providers and that the default provider is Firebase . Because the Laboratory only delegates its work to FeatureStorage , it is FeatureStorage that needs to understand how to connect feature flags with their sources. This is possible with a special implementation of this interface that is available as an extension function. val sourcedFeatureStorage = FeatureStorage . sourced ( localSource = FeatureStorage . inMemory (), remoteSources = mapOf ( \"Firebase\" to FeatureStorage . inMemory (), \"Azure\" to FeatureStorage . inMemory (), ), ) sourcedFeatureStorage delegates persistence mechanism to three different storage and is responsible for coordinating a selected source and a current feature flag option. One error-prone thing is that sourcedFeatureStorage relies on strings and source names to use the correct storage. The reason for this is that two different feature flags might share sources partially. Tip Using Gradle plugin allows you to avoid this issue with the generation of a custom FeatureStorage that is always up-to-date. enum class PowerType : Feature < PowerType > { Coal , Wind , Solar ; public override val defaultOption get () = Solar @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Firebase , Azure ; public override val defaultOption get () = Firebase } } enum class Theme : Feature < PowerType > { Night , Day , Christmas ; public override val defaultOption get () = Night @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Azure ; public override val defaultOption get () = Local } } In this case, Theme and PowerType feature flags share Azure source, but Firebase applies only to the PowerType flag. // Create laboratory that understands sourced features val laboratory = Laboratory . create ( sourcedFeatureStorage ) // Check option of PowerType in Firebase FeatureStorage val powerTypeFirebaseValue = laboratory . experiment < PowerType > () // Check option of Theme in local FeatureStorage val themeLocalValue = laboratory . experiment < Theme > () // Set source of Theme source to Azure (PowerType is still unaffected and uses Firebase) val success = laboratory . setOption ( Theme . Source . Azure ) // Check option of Theme in Azure FeatureStorage val themeAzureValue = laboratory . experiment < Theme > () Info The implementation of sourcedFeatureStorage provided by the library saves data only in localSource . To propagate remote feature flag options on updates, they need to be connected to a remote source. enum class ShowAds : Feature < ShowAds > { Enabled , Disabled ; public override val defaultOption get () = Disabled @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Remote ; public override val defaultOption get () = Remote } } val firebaseStorage = FeatureStorage . inMemory () val sourcedFeatureStorage = FeatureStorage . sourced ( localSource = FeatureStorage . inMemory (), remoteSources = mapOf ( \"Remote\" to firebaseStorage ), ) // During application initialisation val laboratory = Laboratory . create ( sourcedFeatureStorage ) remoteService . observeShowAdsFlag () // Some custom mapping between a service option and a feature flag . map { showAds : Boolean -> val showAdsFlag = if ( showAds ) ShowAds . Enabled else ShowAds . Disabled laboratory . setOption ( showAdsFlag ) } // Scope should last for the lifetime of an application . launchIn ( GlobalScope ) Default options override \u00b6 Whenever Laboratory reads an option for a feature flag, it falls back to a default option declared on a said flag. However, there might be cases when you\u2019d like to change the default behavior. One example might be having features enabled by default in your debug builds and disabled on production. Or you might use feature flags for configuration, and you\u2019d like to have a different configuration per build variant. Laboratory enables this with default options overrides. enum class ShowAds : Feature < ShowAds > { Enabled , Disabled ; public override val defaultOption get () = Disabled } object DebugDefaultOptionFactory : DefaultOptionFactory { override fun < T : Feature < T > > create ( feature : T ): Feature <*>? = when ( feature ) { is ShowAds -> ShowAds . Enabled else -> null } } val laboratory = Laboratory . builder () . featureStorage ( FeatureStorage . inMemory ()) . defaultOptionFactory ( DebugDefaultOptionFactory ) . build () // Uses default option declared in DebugDefaultOptionFactory laboratory . experimentIs ( ShowAds . Enabled ) You can be even more creative and, for example, enable all feature flags in your debug builds, which have an option Enabled . class DebugDefaultOptionFactory : DefaultOptionFactory { override fun < T : Feature < T > > create ( feature : T ): Feature <*>? { return feature . options . associateBy { it . name } [ \"Enabled\" ] } private val < T : Feature < T >> T . options get () = javaClass . options } Feature flag supervision \u00b6 Feature flags can be supervised using FeatureFlag.supervisorOption property. Whenever supervisor has its option different from the value in this property then the supervised feature flag cannot return any other option than a default one. Option can still be set via Laboratory but it will not be exposed as long as a feature flag is not supervised. This relationship is recursive meaning that grandparents control grandchildren indirectly. enum class ChristmasTheme : Feature < ChristmasTheme > { Enabled , Disabled , ; public override val defaultOption get () = Disabled } enum class Greeting : Feature < Greeting > { Hello , HoHoHo , ; public override val defaultOption get () = Hello public override val supervisorOption get () = ChristmasTheme . Enabled } enum class Background : Feature < Background > { White , Reindeer , Snowman , ; public override val defaultOption get () = White public override val supervisorOption get () = ChristmasTheme . Enabled } val laboratory = Laboratory . inMemory () laboratory . setOptions ( Greeting . HoHoHo , Background . Reindeer ) laboratory . experimentIs ( Greeting . HoHoHo ) // false laboratory . experimentIs ( Background . Reindeer ) // false laboratory . setOption ( ChristmasTheme . Enabled ) laboratory . experimentIs ( Greeting . HoHoHo ) // true laboratory . experimentIs ( Background . Reindeer ) // true Listening to remote change \u00b6 Feature flags can be synced with a remote source with a help of OptionFactory . Below is a sample setup using Firebase. enum class ChristmasTheme : Feature < ChristmasTheme > { Enabled , Disabled , ; public val override val defaultOption get () = Disabled } enum class ShowAds : Feature < ShowAds > { Enabled , Disabled ; public override val defaultOption get () = Disabled } object CustomOptionFactory : OptionFactory { private val optionMapping = mapOf < String , ( String ) -> Feature <*>?> ( \"ChristmasTheme\" to { name -> ChristmasTheme :: class . java . options . firstOrNull { it . name == name } }, \"ShowAds\" to { name -> ShowAds :: class . java . options . firstOrNull { it . name == name } }, ) override fun create ( key : String , name : String ) = optionMapping [ key ]?. invoke ( name ) } class App : Application { override fun onCreate () { val firebaseStorage = FeatureStorage . inMemory () // Get a reference to a node where feature flags are kept val database = FirebaseDatabase . getInstance (). reference . child ( \"featureFlags\" ) val featureFlagListener = object : ValueEventListener { override fun onDataChange ( snapshot : DataSnapshot ) { val newOptions = ( snapshot . value as? Map <* , *> ) . orEmpty () . mapNotNull { ( key , value ) -> val stringKey = key as? String ?: return @mapNotNull null val stringValue = value as? String ?: return @mapNotNull null CustomOptionFactory . create ( stringKey , stringValue ) } // Be cautious with using GlobalScope. GlobalScope . launch { firebaseStorage . setOptions ( newOptions ) } } override fun onCancelled ( error : DatabaseError ) = Unit } database . child ( \"featureFlags\" ). addValueEventListener ( featureFlagListener ) } }","title":"User guide"},{"location":"user-guide/#user-guide","text":"","title":"User guide"},{"location":"user-guide/#features","text":"Feature flags are nothing more than enums that implement the Feature interface. It allows us to define a default option, remote sources that can provide different options and descriptions for some human-readable metadata. Danger Feature enums must have at least one option. Defining an enum like below will make Laboratory throw an exception when used to read an option. enum class SomeFeature : Feature < SomeFeature > Tip Check the samples to learn by example.","title":"Features"},{"location":"user-guide/#io","text":"Laboratory is nothing more than a high-level API over the FeatureStorage interface responsible for persisting feature flags. All implementations that are provided by this library rely on a feature flag package name and an enum name. Warning Because the persistence mechanism relies on package names and enum names, you should be careful when refactoring feature flags already available on production. Changing these options may result in a perception of unsaved feature flags. Because FeatureStorage is an interface that is meant to be used with I/O operations, it exposes only suspend functions. Laboratory , on the other hand, allows you to opt-into blocking equivalents of read and write functions. You can selectively do this by applying the @BlockingIoCall annotation or globally by adding a compiler flag. android { kotlinOptions { freeCompilerArgs += [ \"-Xopt-in=io.mehow.laboratory.BlockingIoCall\" , ] } } In either case, a design that relies on non-blocking function calls is preferable.","title":"I/O"},{"location":"user-guide/#sources","text":"Feature flags, by default, have only a single source for their options. By convention, it is considered to be a local source. However, you might need to have different data sources for feature flags, depending on some runtime conditions or a build variant. For example, you might want to use a local source during debugging and rely on some remote services on production. Let\u2019s say that you want to have a feature flag that has three sources. One local, and two remote ones. Info Notice that a feature flag source is also a feature flag. This allows us to change feature flag sources via Laboratory as well. enum class PowerType : Feature < PowerType > { Coal , Wind , Solar ; public override val defaultOption get () = Solar @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Firebase , Azure ; public override val defaultOption get () = Firebase } } If you define multiple sources for a feature flag, you should add a Local option to them. This allows changing feature flag options at runtime from the QA module . This feature flag definition allows configuring Laboratory in a way that it is capable of recognizing that PowerType has different option providers and that the default provider is Firebase . Because the Laboratory only delegates its work to FeatureStorage , it is FeatureStorage that needs to understand how to connect feature flags with their sources. This is possible with a special implementation of this interface that is available as an extension function. val sourcedFeatureStorage = FeatureStorage . sourced ( localSource = FeatureStorage . inMemory (), remoteSources = mapOf ( \"Firebase\" to FeatureStorage . inMemory (), \"Azure\" to FeatureStorage . inMemory (), ), ) sourcedFeatureStorage delegates persistence mechanism to three different storage and is responsible for coordinating a selected source and a current feature flag option. One error-prone thing is that sourcedFeatureStorage relies on strings and source names to use the correct storage. The reason for this is that two different feature flags might share sources partially. Tip Using Gradle plugin allows you to avoid this issue with the generation of a custom FeatureStorage that is always up-to-date. enum class PowerType : Feature < PowerType > { Coal , Wind , Solar ; public override val defaultOption get () = Solar @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Firebase , Azure ; public override val defaultOption get () = Firebase } } enum class Theme : Feature < PowerType > { Night , Day , Christmas ; public override val defaultOption get () = Night @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Azure ; public override val defaultOption get () = Local } } In this case, Theme and PowerType feature flags share Azure source, but Firebase applies only to the PowerType flag. // Create laboratory that understands sourced features val laboratory = Laboratory . create ( sourcedFeatureStorage ) // Check option of PowerType in Firebase FeatureStorage val powerTypeFirebaseValue = laboratory . experiment < PowerType > () // Check option of Theme in local FeatureStorage val themeLocalValue = laboratory . experiment < Theme > () // Set source of Theme source to Azure (PowerType is still unaffected and uses Firebase) val success = laboratory . setOption ( Theme . Source . Azure ) // Check option of Theme in Azure FeatureStorage val themeAzureValue = laboratory . experiment < Theme > () Info The implementation of sourcedFeatureStorage provided by the library saves data only in localSource . To propagate remote feature flag options on updates, they need to be connected to a remote source. enum class ShowAds : Feature < ShowAds > { Enabled , Disabled ; public override val defaultOption get () = Disabled @Suppress ( \"UNCHECKED_CAST\" ) override val source = Source :: class . java as Class < Feature <*>> enum class Source : Feature < Source > { Local , Remote ; public override val defaultOption get () = Remote } } val firebaseStorage = FeatureStorage . inMemory () val sourcedFeatureStorage = FeatureStorage . sourced ( localSource = FeatureStorage . inMemory (), remoteSources = mapOf ( \"Remote\" to firebaseStorage ), ) // During application initialisation val laboratory = Laboratory . create ( sourcedFeatureStorage ) remoteService . observeShowAdsFlag () // Some custom mapping between a service option and a feature flag . map { showAds : Boolean -> val showAdsFlag = if ( showAds ) ShowAds . Enabled else ShowAds . Disabled laboratory . setOption ( showAdsFlag ) } // Scope should last for the lifetime of an application . launchIn ( GlobalScope )","title":"Sources"},{"location":"user-guide/#default-options-override","text":"Whenever Laboratory reads an option for a feature flag, it falls back to a default option declared on a said flag. However, there might be cases when you\u2019d like to change the default behavior. One example might be having features enabled by default in your debug builds and disabled on production. Or you might use feature flags for configuration, and you\u2019d like to have a different configuration per build variant. Laboratory enables this with default options overrides. enum class ShowAds : Feature < ShowAds > { Enabled , Disabled ; public override val defaultOption get () = Disabled } object DebugDefaultOptionFactory : DefaultOptionFactory { override fun < T : Feature < T > > create ( feature : T ): Feature <*>? = when ( feature ) { is ShowAds -> ShowAds . Enabled else -> null } } val laboratory = Laboratory . builder () . featureStorage ( FeatureStorage . inMemory ()) . defaultOptionFactory ( DebugDefaultOptionFactory ) . build () // Uses default option declared in DebugDefaultOptionFactory laboratory . experimentIs ( ShowAds . Enabled ) You can be even more creative and, for example, enable all feature flags in your debug builds, which have an option Enabled . class DebugDefaultOptionFactory : DefaultOptionFactory { override fun < T : Feature < T > > create ( feature : T ): Feature <*>? { return feature . options . associateBy { it . name } [ \"Enabled\" ] } private val < T : Feature < T >> T . options get () = javaClass . options }","title":"Default options override"},{"location":"user-guide/#feature-flag-supervision","text":"Feature flags can be supervised using FeatureFlag.supervisorOption property. Whenever supervisor has its option different from the value in this property then the supervised feature flag cannot return any other option than a default one. Option can still be set via Laboratory but it will not be exposed as long as a feature flag is not supervised. This relationship is recursive meaning that grandparents control grandchildren indirectly. enum class ChristmasTheme : Feature < ChristmasTheme > { Enabled , Disabled , ; public override val defaultOption get () = Disabled } enum class Greeting : Feature < Greeting > { Hello , HoHoHo , ; public override val defaultOption get () = Hello public override val supervisorOption get () = ChristmasTheme . Enabled } enum class Background : Feature < Background > { White , Reindeer , Snowman , ; public override val defaultOption get () = White public override val supervisorOption get () = ChristmasTheme . Enabled } val laboratory = Laboratory . inMemory () laboratory . setOptions ( Greeting . HoHoHo , Background . Reindeer ) laboratory . experimentIs ( Greeting . HoHoHo ) // false laboratory . experimentIs ( Background . Reindeer ) // false laboratory . setOption ( ChristmasTheme . Enabled ) laboratory . experimentIs ( Greeting . HoHoHo ) // true laboratory . experimentIs ( Background . Reindeer ) // true","title":"Feature flag supervision"},{"location":"user-guide/#listening-to-remote-change","text":"Feature flags can be synced with a remote source with a help of OptionFactory . Below is a sample setup using Firebase. enum class ChristmasTheme : Feature < ChristmasTheme > { Enabled , Disabled , ; public val override val defaultOption get () = Disabled } enum class ShowAds : Feature < ShowAds > { Enabled , Disabled ; public override val defaultOption get () = Disabled } object CustomOptionFactory : OptionFactory { private val optionMapping = mapOf < String , ( String ) -> Feature <*>?> ( \"ChristmasTheme\" to { name -> ChristmasTheme :: class . java . options . firstOrNull { it . name == name } }, \"ShowAds\" to { name -> ShowAds :: class . java . options . firstOrNull { it . name == name } }, ) override fun create ( key : String , name : String ) = optionMapping [ key ]?. invoke ( name ) } class App : Application { override fun onCreate () { val firebaseStorage = FeatureStorage . inMemory () // Get a reference to a node where feature flags are kept val database = FirebaseDatabase . getInstance (). reference . child ( \"featureFlags\" ) val featureFlagListener = object : ValueEventListener { override fun onDataChange ( snapshot : DataSnapshot ) { val newOptions = ( snapshot . value as? Map <* , *> ) . orEmpty () . mapNotNull { ( key , value ) -> val stringKey = key as? String ?: return @mapNotNull null val stringValue = value as? String ?: return @mapNotNull null CustomOptionFactory . create ( stringKey , stringValue ) } // Be cautious with using GlobalScope. GlobalScope . launch { firebaseStorage . setOptions ( newOptions ) } } override fun onCancelled ( error : DatabaseError ) = Unit } database . child ( \"featureFlags\" ). addValueEventListener ( featureFlagListener ) } }","title":"Listening to remote change"}]}